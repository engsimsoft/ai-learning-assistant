# Урок 4.2: Fetch API - Связь Frontend с Backend

> **Модуль 4:** Frontend разработка  
> **Урок:** 4.2  
> **Длительность:** 40-50 минут  
> **Prerequisite:** Урок 4.1 (HTML/CSS/JavaScript основы), Урок 1.4 (REST API)

---

## 🎯 Цели урока

После этого урока ты сможешь:
- ✅ Понимать как JavaScript отправляет HTTP запросы из браузера
- ✅ Объяснить концепцию асинхронности в веб-приложениях
- ✅ Знать разницу между GET, POST, PUT, DELETE запросами из frontend
- ✅ Понимать как обрабатывать JSON ответы от backend
- ✅ Сформулировать задачу для Claude Code на создание frontend с API запросами
- ✅ Применить Fetch API для EngineCamPro v2

---

## 📖 Концепция: Что такое Fetch API?

### Простое определение

**Fetch API** - это встроенный в браузер инструмент JavaScript для отправки HTTP запросов на сервер и получения ответов.

Это мост между твоим frontend (JavaScript в браузере) и backend (FastAPI на сервере).

### Зачем это нужно

Без Fetch API:
- ❌ JavaScript не может получить данные с сервера
- ❌ Страница не интерактивна - всё статично
- ❌ Нужна перезагрузка страницы для каждого действия
- ❌ Нет связи между frontend и backend

С Fetch API:
- ✅ JavaScript отправляет данные на backend
- ✅ Backend обрабатывает и возвращает результат
- ✅ Страница обновляется без перезагрузки
- ✅ Полная интерактивность приложения

### 📮 Аналогия: Отправка письма с вопросом

Представь, что Fetch API - это почтовая служба между твоим домом (браузер) и офисом (сервер):

```
┌─────────────────────────────────────────────────────────┐
│              FETCH API = ПОЧТОВАЯ СЛУЖБА                 │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  🏠 ДОМ (Браузер)              🏢 ОФИС (Сервер)         │
│                                                         │
│  Ты (JavaScript)               Эксперт (Backend API)    │
│                                                         │
│  1️⃣ Пишешь письмо с вопросом                            │
│     "Рассчитай профиль                                  │
│      кулачка с параметрами:                             │
│      radius=50, lift=10"                                │
│          │                                              │
│          │  📮 Отправка (fetch)                         │
│          │                                              │
│          └──────────►  2️⃣ Письмо доставлено              │
│                          Эксперт читает                 │
│                          Делает расчёты                 │
│                          Пишет ответ                    │
│                              │                          │
│          ◄──────────┐  3️⃣ Ответ отправлен               │
│          │          │     "Вот результаты:             │
│          │          │      [массив координат]"         │
│          │                                              │
│  4️⃣ Получаешь ответ                                     │
│     Читаешь данные                                      │
│     Рисуешь график                                      │
│                                                         │
│  ⏱️ ВАЖНО: Пока ждёшь ответа - можешь заниматься        │
│     другими делами! (асинхронность)                     │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**Ключевые моменты аналогии:**

**Ты не ждёшь у почтового ящика:**
- Отправил письмо → продолжаешь жить
- Когда придёт ответ - почтальон позвонит в дверь
- Это и есть **асинхронность**

**Формат письма важен:**
- GET запрос = открытка с вопросом
- POST запрос = письмо с документами
- Ответ приходит в формате JSON = структурированный документ

---

## 🔄 Ключевая концепция: Асинхронность

### Что такое асинхронность?

Представь ресторан:

**Синхронный подход (БЕЗ Fetch, плохо):**
```
Официант → Кухня
Официант СТОИТ и ждёт пока приготовят блюдо
Другие посетители НЕ могут сделать заказ
Ресторан работает медленно
```

**Асинхронный подход (С Fetch, хорошо):**
```
Официант → Кухня (передал заказ)
Официант ИДЁТ обслуживать других клиентов
Кухня готовит параллельно
Когда блюдо готово → официант получает сигнал
Официант приносит блюдо
```

### В веб-приложении

**Без асинхронности:**
- JavaScript отправил запрос
- Страница ЗАМОРАЖИВАЕТСЯ
- Пользователь НЕ может ничего делать
- Ждём ответа...
- Страница разморозилась

**С асинхронностью (Fetch API):**
- JavaScript отправил запрос
- Страница ПРОДОЛЖАЕТ работать
- Пользователь может кликать, вводить текст
- Когда ответ пришёл → JavaScript его обрабатывает
- Плавный UX

### Визуальная схема

```
СИНХРОННЫЙ (плохо):
═══════════════════════════════════════
User action → [ЖДЁМ...блокировка...] → Result
             (страница мертва)

АСИНХРОННЫЙ (хорошо):
═══════════════════════════════════════
User action → [отправка запроса]
              └── страница живая ──┐
              └── user может кликать ──┐
              └── можно показать spinner ──┐
                                          ↓
              [ответ пришёл] → Result отображается
```

---

## 🌐 Как работает Fetch API

### Общая схема

```
┌──────────────────────────────────────────────────────┐
│           FRONTEND (JavaScript в браузере)            │
├──────────────────────────────────────────────────────┤
│                                                      │
│  1️⃣ Пользователь нажал кнопку                        │
│     ↓                                                │
│  2️⃣ JavaScript собирает данные из формы              │
│     data = {base_radius: 50, lift: 10, duration: 180}│
│     ↓                                                │
│  3️⃣ Fetch отправляет HTTP запрос                     │
│     fetch('http://localhost:8000/api/cams/calculate',│
│           method: POST, body: JSON)                  │
│     ↓                                                │
│  ⏱️ АСИНХРОННОЕ ОЖИДАНИЕ (страница живая!)           │
│     ↓                                                │
│  4️⃣ Ответ получен от backend                         │
│     response = {profile: [...], max_velocity: 23.5}  │
│     ↓                                                │
│  5️⃣ JavaScript обрабатывает JSON                     │
│     Рисует график                                    │
│     Показывает результаты                            │
│                                                      │
└──────────────────────────────────────────────────────┘
                        ↕
           🌐 HTTP через интернет
                        ↕
┌──────────────────────────────────────────────────────┐
│               BACKEND (FastAPI на сервере)            │
├──────────────────────────────────────────────────────┤
│                                                      │
│  1️⃣ Получил POST запрос на /api/cams/calculate       │
│     ↓                                                │
│  2️⃣ Валидация данных (Pydantic)                      │
│     ↓                                                │
│  3️⃣ Расчёт профиля кулачка (NumPy)                   │
│     ↓                                                │
│  4️⃣ Формирование JSON ответа                         │
│     ↓                                                │
│  5️⃣ Отправка ответа frontend                         │
│                                                      │
└──────────────────────────────────────────────────────┘
```

---

## 🔧 Типы HTTP запросов из Frontend

### GET - Получить данные

**Когда использовать:**
- Получить список всех кулачков
- Получить один кулачок по ID
- Получить информацию об API

**Концепция:**
```
Frontend: "Дай мне список всех проектов"
          ↓
Backend:  [проект1, проект2, проект3]
```

### POST - Создать новое

**Когда использовать:**
- Создать новый кулачок
- Выполнить расчёт профиля
- Зарегистрировать пользователя

**Концепция:**
```
Frontend: "Вот данные нового кулачка: {name, params}"
          ↓
Backend:  "Создал! Вот ID: 123"
```

### PUT - Обновить существующее

**Когда использовать:**
- Обновить параметры кулачка
- Изменить настройки проекта

**Концепция:**
```
Frontend: "Обнови кулачок ID=5, новые параметры: {...}"
          ↓
Backend:  "Обновил!"
```

### DELETE - Удалить

**Когда использовать:**
- Удалить кулачок
- Удалить проект

**Концепция:**
```
Frontend: "Удали кулачок ID=5"
          ↓
Backend:  "Удалил!"
```

---

## 💡 Контекст применения

### Когда используется Fetch API

**Fetch нужен всегда когда:**
- ✅ Frontend и Backend разделены (наш случай!)
- ✅ Нужна интерактивность без перезагрузки страницы
- ✅ Приложение работает с данными на сервере
- ✅ REST API архитектура

**Fetch НЕ нужен когда:**
- ⚠️ Статический сайт без backend
- ⚠️ Next.js Full-Stack с Server Actions (другой подход)
- ⚠️ Все данные уже в браузере

### Для EngineCamPro v2

**Как мы будем использовать Fetch:**

1. **Получение списка проектов:**
```
GET /api/projects → список всех проектов пользователя
```

2. **Создание нового кулачка:**
```
POST /api/cams → создать кулачок с параметрами
```

3. **Расчёт профиля:**
```
POST /api/cams/{id}/calculate → получить координаты профиля
```

4. **Обновление параметров:**
```
PUT /api/cams/{id} → обновить параметры существующего кулачка
```

5. **Удаление кулачка:**
```
DELETE /api/cams/{id} → удалить кулачок
```

---

## 🔄 Обработка ответов и ошибок

### Три возможных сценария

```
┌─────────────────────────────────────────┐
│      ОТПРАВКА ЗАПРОСА                    │
└───────────┬─────────────────────────────┘
            │
            ├──► 1️⃣ Успех (200, 201)
            │    └─► Получить JSON
            │        Обработать данные
            │        Показать результат
            │
            ├──► 2️⃣ Ошибка клиента (400, 404, 422)
            │    └─► Backend сказал "данные неверны"
            │        Показать сообщение пользователю
            │        "Проверьте введённые параметры"
            │
            └──► 3️⃣ Ошибка сети или сервера (500, network error)
                 └─► Backend недоступен или упал
                     Показать "Сервер временно недоступен"
                     Предложить повторить позже
```

### Важность error handling

**Плохой опыт (без обработки ошибок):**
- Пользователь нажал кнопку
- Ничего не произошло
- Пользователь не понимает что случилось
- Приложение выглядит сломанным

**Хороший опыт (с обработкой):**
- Пользователь нажал кнопку
- Показался spinner "Loading..."
- Если ошибка → понятное сообщение
- Пользователь знает что делать дальше

---

## 🤖 Работа с Claude Code

### Сценарий: Создание страницы с CRUD операциями

#### ❌ Плохой диалог (неэффективный)

```
Ты: Сделай страницу которая отправляет запросы на backend

Claude Code: Какие запросы? На какие endpoints? Что делать с ответами?
```

**Проблемы:**
- Не указаны HTTP методы
- Не указаны endpoints
- Нет требований к UI
- Нет обработки ошибок

#### ✅ Хороший диалог (эффективный)

```
Ты: Создай веб-страницу для управления кулачками через REST API.

Требования к структуре:
- HTML: форма создания кулачка, таблица списка кулачков, 
  кнопки действий
- CSS: современный дизайн, Grid layout, адаптивная вёрстка
- JavaScript с Fetch API для всех операций

API endpoints (FastAPI backend на localhost:8000):
- GET /api/cams - получить все кулачки
- POST /api/cams - создать новый (body: {name, base_radius, 
  lift, duration})
- GET /api/cams/{id} - получить один кулачок
- PUT /api/cams/{id} - обновить кулачок
- DELETE /api/cams/{id} - удалить кулачок

Функциональность:
- При загрузке страницы → GET запрос, показать список
- Форма создания → POST запрос, добавить в список
- Кнопка "Edit" → заполнить форму, PUT запрос
- Кнопка "Delete" → DELETE запрос, удалить из списка
- Кнопка "Calculate" → POST на /api/cams/{id}/calculate

Error handling:
- Try-catch для всех fetch запросов
- Показать alert если ошибка
- Loading индикаторы для всех операций
- Валидация формы перед отправкой

Один файл index.html со встроенным CSS и JS.

Claude Code: [анализирует требования]
Создам страницу со следующими компонентами:

1. HTML структура:
   - Форма с полями (name, base_radius, lift, duration)
   - Таблица для отображения кулачков
   - Кнопки действий (Edit, Delete, Calculate)

2. JavaScript функции:
   - fetchCams() - GET список
   - createCam() - POST новый
   - updateCam() - PUT обновление
   - deleteCam() - DELETE удаление
   - calculateProfile() - POST расчёт

3. Особенности:
   - Async/await для асинхронности
   - Try-catch для ошибок
   - Loading states
   - Автообновление списка после операций

Применить? [Y/n]

Ты: Y

Claude Code: [создаёт index.html с полным CRUD функционалом]

Создан index.html. Что включено:
- Все CRUD операции через Fetch API
- Error handling с информативными сообщениями
- Loading индикаторы для UX
- Адаптивный дизайн

Протестируй с запущенным FastAPI backend. Хочешь что-то 
добавить?

Ты: Добавь подтверждение перед удалением кулачка

Claude Code: [добавляет confirm() диалог]
Готово! Теперь перед удалением показывается диалог 
"Are you sure you want to delete this cam?"

Ты: Отлично! Теперь добавь отображение результатов расчёта 
в виде таблицы координат

Claude Code: [добавляет модальное окно с таблицей результатов]
Добавил:
- Модальное окно для результатов
- Таблица координат (angle, radius)
- Кнопка закрытия модального окна
- CSS стили для модалки
```

**Почему это эффективно:**
- ✅ Все endpoints указаны явно
- ✅ Описаны HTTP методы и body параметры
- ✅ Требования к UI и UX
- ✅ Error handling упомянут
- ✅ Итеративное улучшение через диалог
- ✅ Конкретные функции описаны

---

## 🛠️ Практическое задание

### Задача

Создай веб-страницу которая тестирует все CRUD операции твоего FastAPI backend из Модуля 2.

### Работа с Claude Code

**Шаг 1:** Убедись что backend запущен
```bash
cd ~/projects/enginecampro-v2/backend
uvicorn app.main:app --reload

# Backend должен быть доступен на http://localhost:8000
# Проверь в браузере: http://localhost:8000/docs
```

**Шаг 2:** Открой терминал для frontend
```bash
cd ~/projects/enginecampro-v2/frontend
claude
```

**Шаг 3:** Диалог с Claude Code

```
Ты: Создай CRUD тестер для моего FastAPI backend.

Требования:

HTML структура:
- Заголовок "EngineCamPro - Cam Manager"
- Секция "Create New Cam" с формой:
  * Input: name (text)
  * Input: base_radius (number)
  * Input: lift (number)
  * Input: duration (number)
  * Button: "Create Cam"
- Секция "Existing Cams" с таблицей:
  * Колонки: ID, Name, Base Radius, Lift, Duration, Actions
  * Actions: кнопки Edit, Delete, Calculate

CSS:
- Современный дизайн с CSS Grid
- Форма и таблица в отдельных секциях
- Кнопки с разными цветами (Create=green, Edit=blue, 
  Delete=red, Calculate=orange)
- Адаптивная вёрстка
- Loading индикаторы (spinner или текст)

JavaScript с Fetch API:
- GET /api/cams - загрузить все кулачки при открытии страницы
- POST /api/cams - создать новый кулачок из формы
- PUT /api/cams/{id} - обновить (после Edit)
- DELETE /api/cams/{id} - удалить с подтверждением
- POST /api/cams/{id}/calculate - получить профиль

Обработка ответов:
- Успех (200/201) → обновить таблицу, показать success message
- Ошибка (400/422/500) → показать alert с описанием ошибки
- Network error → показать "Backend недоступен"

Валидация:
- Все поля формы обязательны
- Числа должны быть положительными
- Проверка перед отправкой

UX улучшения:
- Disable кнопки во время запроса
- Показать "Loading..." или spinner
- Автоматически обновлять список после операций
- Очищать форму после успешного создания

Один файл crud-tester.html со встроенным CSS и JS.

Claude Code: [создаёт полноценный CRUD тестер]
```

**Шаг 4:** Тестирование

1. Открой `crud-tester.html` в браузере

2. Проверь каждую операцию:
   - [ ] Создание нового кулачка (POST)
   - [ ] Загрузка списка при открытии (GET)
   - [ ] Обновление кулачка (PUT)
   - [ ] Удаление кулачка (DELETE)
   - [ ] Расчёт профиля (POST calculate)

3. Проверь error handling:
   - [ ] Выключи backend → должна показаться ошибка сети
   - [ ] Отправь невалидные данные → должна показаться ошибка валидации
   - [ ] Попробуй удалить несуществующий ID → 404 error

### Ожидаемый результат

- ✅ Все CRUD операции работают
- ✅ UI обновляется автоматически после действий
- ✅ Ошибки обрабатываются и показываются пользователю
- ✅ Loading states показываются во время запросов
- ✅ Валидация работает
- ✅ Дизайн выглядит современно

---

## 🎓 Что ты узнал из этого урока

### Ключевые концепции

1. **Fetch API = мост между frontend и backend**
   - Отправляет HTTP запросы из JavaScript
   - Получает ответы и обрабатывает их

2. **Асинхронность - это важно**
   - Запросы не блокируют страницу
   - Пользователь может продолжать работу
   - Улучшает UX

3. **Разные HTTP методы для разных задач**
   - GET - получить данные
   - POST - создать новое
   - PUT - обновить
   - DELETE - удалить

4. **Error handling критичен**
   - Сеть может упасть
   - Backend может вернуть ошибку
   - Пользователю нужна обратная связь

5. **JSON - формат обмена данными**
   - Backend отправляет JSON
   - Frontend парсит JSON
   - JavaScript работает с объектами

---

## ❓ Вопросы для самопроверки

1. **Объясни асинхронность своими словами**
   - Почему это важно для UX?
   - Что будет если запросы синхронные?

2. **Зачем нужны разные HTTP методы?**
   - Почему нельзя всё делать через POST?
   - В чём смысл REST архитектуры?

3. **Как обрабатывать ошибки?**
   - Какие типы ошибок бывают?
   - Что показывать пользователю?

4. **Для EngineCamPro v2:**
   - Какие Fetch запросы нам понадобятся?
   - Когда использовать GET, а когда POST?

5. **Vanilla Fetch vs библиотеки:**
   - Зачем нужны библиотеки типа Axios?
   - Когда достаточно Fetch API?

6. **Формулировка задачи для Claude Code:**
   - Что критично указать для Fetch запросов?
   - Какие детали нужны для правильной реализации?

---

## 🔗 Связь с другими уроками

**Основано на уроках:**
- Урок 1.2: HTTP протокол - Fetch использует HTTP
- Урок 1.4: REST API - понимание endpoints и методов
- Урок 4.1: JavaScript основы - Fetch это JavaScript API

**Подготавливает к урокам:**
- Урок 4.3: React - в React используем те же концепции Fetch
- Урок 5.1: Frontend-Backend интеграция - полный цикл
- Урок 4.5: Визуализация - будем получать данные через Fetch

**Связь с EngineCamPro:**
В следующих уроках мы создадим полноценный frontend:
- Fetch получит параметры кулачка от backend
- Fetch отправит запрос на расчёт профиля
- Fetch получит координаты для построения графика
- React компоненты будут использовать Fetch для всех операций

---

## ✅ Критерии завершения урока

**Понимание концепций:**
- [ ] Понимаю что такое Fetch API и зачем он нужен
- [ ] Могу объяснить концепцию асинхронности
- [ ] Знаю разницу между GET/POST/PUT/DELETE
- [ ] Понимаю важность error handling

**Практические навыки:**
- [ ] Могу сформулировать задачу с Fetch для Claude Code
- [ ] Понимаю структуру Fetch запроса (method, headers, body)
- [ ] Знаю как обрабатывать JSON ответы
- [ ] Понимаю обработку ошибок (try-catch)

**Готовность к следующему уроку:**
- [ ] Создан CRUD тестер
- [ ] Все операции работают с backend
- [ ] Error handling реализован
- [ ] Понимаю как frontend общается с REST API

---

**Статус урока:** ⏳ Не начат / 🔄 В процессе / ✅ Завершён  
**Дата начала:** _________  
**Дата завершения:** _________

---

## 📚 Дополнительные материалы (опционально)

Если хочешь узнать больше:
- [MDN Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) - официальная документация
- [JavaScript Promises](https://javascript.info/promise-basics) - глубже про асинхронность

**НО!** Главное - понять концепции из этого урока. Claude Code напишет правильный Fetch код за тебя!