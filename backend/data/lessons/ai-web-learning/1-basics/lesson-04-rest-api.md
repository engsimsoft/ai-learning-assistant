# Урок 1.4: REST API концепции

> **Модуль 1:** Основы веб-архитектуры  
> **Урок:** 1.4 (финальный урок модуля)  
> **Длительность:** 60-75 минут  
> **Prerequisite:** Уроки 1.1, 1.2, 1.3

---

## 🎯 Цели урока

После этого урока ты сможешь:
- ✅ Понимать что такое REST и зачем нужны правила для API
- ✅ Знать 6 принципов REST архитектуры
- ✅ Проектировать правильные URL для API
- ✅ Применять best practices для REST API
- ✅ Отличать хороший API дизайн от плохого
- ✅ Спроектировать REST API для EngineCamPro

---

## 📖 Концепция: Что такое REST?

### Простое определение

**REST** (Representational State Transfer) - это набор **правил и соглашений** для построения API.

**Важно:** REST - это НЕ технология и НЕ протокол! Это просто **архитектурный стиль**, набор рекомендаций "как правильно делать API".

### 🏗️ Аналогия: Правила дорожного движения

```
┌─────────────────────────────────────────────────────────┐
│              БЕЗ ПРАВИЛ ДОРОЖНОГО ДВИЖЕНИЯ              │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Каждый едет как хочет:                                 │
│  • Кто-то по правой стороне                             │
│  • Кто-то по левой                                      │
│  • Светофор: красный = стой или можно?                  │
│  • Знаки: каждый город придумывает свои                 │
│                                                         │
│  Результат: ХАОС! ❌                                     │
│                                                         │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│              С ПРАВИЛАМИ ДОРОЖНОГО ДВИЖЕНИЯ             │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Единые правила:                                        │
│  • Едем по правой стороне (в РФ)                        │
│  • Красный = стоп, зелёный = можно                      │
│  • Знаки одинаковые во всех городах                     │
│  • Скорость ограничена по типу дороги                   │
│                                                         │
│  Результат: ПОРЯДОК! ✅                                  │
│  Любой водитель понимает что делать                     │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**REST - это "правила дорожного движения" для API:**
- Единые соглашения
- Предсказуемая структура
- Любой разработчик понимает как пользоваться
- Не нужно читать инструкцию на 100 страниц

---

### Зачем нужны правила для API?

**Проблема без REST:**

```
API разработчика А:
- Получить проекты: GET /getProjects
- Создать проект: GET /createProject?name=...
- Удалить проект: POST /deleteProject

API разработчика Б:
- Получить проекты: POST /project/list
- Создать проект: POST /project/new
- Удалить проект: DELETE /projects/123

API разработчика В:
- Получить проекты: GET /api/v1/all-projects
- Создать проект: PUT /api/v1/project-create
- Удалить проект: GET /api/v1/project/remove/123
```

**Каждый делает по-своему! Нужно изучать каждый API отдельно.** ❌

**С REST правилами:**

```
Все делают одинаково:
- Получить проекты: GET /api/projects
- Создать проект: POST /api/projects
- Удалить проект: DELETE /api/projects/123

Сразу понятно что делает каждый endpoint! ✅
```

---

## 🏛️ Шесть принципов REST

REST определяет 6 ключевых принципов. Давай разберём каждый.

### 1️⃣ Client-Server (Разделение клиента и сервера)

**Принцип:** Frontend и Backend - это отдельные независимые приложения.

**Что это значит:**
- Frontend не знает как работает Backend (что внутри)
- Backend не знает как работает Frontend (какой UI)
- Общаются только через API (контракт)

**Аналогия:** Ресторан
- Посетитель (Client) не знает рецепты блюд
- Повар (Server) не знает что посетитель будет делать с блюдом
- Общаются через меню (API)

**Преимущество:**
- ✅ Можно менять Frontend не трогая Backend
- ✅ Можно менять Backend не трогая Frontend
- ✅ Можно создать несколько Frontend (веб, мобильный) для одного Backend

**Для EngineCamPro:**
```
Frontend (React)              Backend (FastAPI)
     │                              │
     │  Я не знаю КАК ты           │  Я не знаю КАК ты
     │  делаешь расчёты            │  отображаешь графики
     │                              │
     │  Я знаю только:             │  Я знаю только:
     │  "отправь POST /calculate"  │  "получу параметры,
     │                              │   верну результат"
     │                              │
     └──────────── API ─────────────┘
```

---

### 2️⃣ Stateless (Без сохранения состояния)

**Принцип:** Каждый HTTP запрос содержит ВСЮ нужную информацию. Сервер не помнит предыдущие запросы.

**Что это значит:**
- Сервер не хранит "кто сейчас работает" в памяти
- Каждый запрос независим
- Всю информацию (токен авторизации) отправляем в каждом запросе

**Аналогия:** Почта
```
Плохо (Stateful):
Письмо 1: "Привет, я Иван"
Письмо 2: "Сколько стоит билет?"
Письмо 3: "Куплю 2 штуки"
← Получатель должен помнить что говорилось в предыдущих письмах

Хорошо (Stateless):
Письмо 1: "Привет, я Иван. Сколько стоит билет в Москву?"
Письмо 2: "Привет, я Иван. Куплю 2 билета в Москву"
← Каждое письмо содержит всю информацию
```

**Пример для API:**

```
❌ Плохо (Stateful):
POST /auth/login          ← сервер запоминает "вошёл Иван"
GET /api/projects         ← сервер помнит что это Иван

✅ Хорошо (Stateless):
POST /auth/login          ← сервер выдаёт токен
Response: {"token": "abc123"}

GET /api/projects
Authorization: Bearer abc123   ← каждый запрос содержит токен
```

**Преимущества:**
- ✅ Можно перезагрузить сервер - ничего не сломается
- ✅ Можно использовать несколько серверов (load balancing)
- ✅ Проще отладка (каждый запрос независим)

---

### 3️⃣ Cacheable (Кэшируемость)

**Принцип:** Ответы сервера можно кэшировать (сохранять) для ускорения.

**Что это значит:**
- Сервер указывает можно ли кэшировать ответ
- Client или промежуточные серверы могут сохранить ответ
- Повторный запрос вернёт сохранённый результат (быстрее!)

**Аналогия:** Шпаргалка
```
Без кэша:
- Каждый раз спрашиваешь "Сколько будет 2+2?"
- Каждый раз вычисляют заново

С кэшем:
- Первый раз спросил "Сколько будет 2+2?" → Ответ: 4
- Записал в блокнот "2+2=4"
- Второй раз не спрашиваешь, смотришь в блокнот
```

**Пример:**
```
GET /api/projects

Response:
Cache-Control: max-age=300    ← можно кэшировать на 5 минут
[{"id": 1, "name": "Project A"}]

Второй запрос в течение 5 минут:
- Браузер не отправляет запрос на сервер
- Берёт данные из кэша
- Быстрее + меньше нагрузка на сервер
```

**Что можно кэшировать:**
- ✅ GET запросы (данные не меняются часто)
- ❌ POST/PUT/DELETE (меняют данные, кэш неактуален)

---

### 4️⃣ Uniform Interface (Единый интерфейс)

**Принцип:** API должен быть предсказуемым и единообразным.

**Это самый важный принцип REST!** Он включает 4 под-правила:

#### 4.1 Идентификация ресурсов

**Каждый ресурс имеет уникальный URL:**

```
/api/projects/123       ← Проект с ID 123
/api/projects/456       ← Проект с ID 456
/api/cams/789           ← Кулачок с ID 789
```

#### 4.2 Манипуляция через представления

**Работаем с ресурсами через JSON (или XML):**

```
GET /api/projects/123
Response: {"id": 123, "name": "My Project"}

PUT /api/projects/123
Body: {"id": 123, "name": "Updated Project"}
```

#### 4.3 Самоописываемые сообщения

**Запрос содержит всю информацию о том как его обработать:**

```
POST /api/projects
Content-Type: application/json    ← "Тело в формате JSON"
Authorization: Bearer abc123      ← "Я авторизован"

{"name": "New Project"}
```

#### 4.4 HATEOAS (опционально)

**Hypermedia As The Engine Of Application State** - ответ содержит ссылки на связанные ресурсы.

Это продвинутая тема, на практике используется редко. Можно игнорировать для начала.

---

### 5️⃣ Layered System (Слоистая система)

**Принцип:** Между Client и Server могут быть промежуточные слои.

**Что это значит:**
- Client не знает к чему подключается напрямую
- Могут быть: кэш-серверы, балансировщики нагрузки, CDN

**Схема:**
```
Client
  │
  ▼
CDN (кэш статики)
  │
  ▼
Load Balancer (распределяет запросы)
  │
  ├─► Backend Server 1
  ├─► Backend Server 2
  └─► Backend Server 3
```

**Client думает:** "Я общаюсь с одним сервером"  
**На самом деле:** Запрос проходит через несколько слоёв

**Преимущество:**
- ✅ Масштабируемость (добавить серверы)
- ✅ Безопасность (firewall между слоями)
- ✅ Производительность (кэширование на разных уровнях)

---

### 6️⃣ Code on Demand (Опционально)

**Принцип:** Сервер может отправить исполняемый код клиенту.

**Пример:** Сервер отправляет JavaScript код, который выполняется в браузере.

**Это опциональный принцип** - большинство REST API его не используют.

Можно игнорировать для изучения.

---

## 🎨 Best Practices для REST API

Теперь конкретные правила как правильно проектировать API.

### 1️⃣ Используй существительные, не глаголы

**Глагол уже есть в HTTP методе!**

```
❌ Плохо:
GET /getProjects
POST /createProject
DELETE /deleteProject
GET /fetchProjectById/123

✅ Хорошо:
GET /projects              ← получить (глагол GET)
POST /projects             ← создать (глагол POST)
DELETE /projects/123       ← удалить (глагол DELETE)
GET /projects/123          ← получить (глагол GET)
```

**Правило:** URL - это имя ресурса (существительное), метод - действие (глагол).

---

### 2️⃣ Используй множественное число

**Для коллекций всегда множественное число:**

```
❌ Плохо:
/project             ← единственное число
/user
/cam

✅ Хорошо:
/projects            ← множественное число
/users
/cams
```

**Почему:**
- `/projects` - коллекция проектов (все)
- `/projects/123` - один элемент из коллекции

Единообразие! Не нужно думать "projects или project?"

---

### 3️⃣ Используй иерархию для связей

**Вложенные ресурсы показывают связь:**

```
✅ Хорошо:
/projects/123/cams           ← кулачки проекта 123
/projects/123/cams/456       ← кулачок 456 проекта 123
/users/789/projects          ← проекты пользователя 789
```

**Читается как:** "Проект 123, его кулачки"

**Но не уходи глубже 2-3 уровней:**

```
⚠️ Слишком глубоко:
/users/1/projects/2/cams/3/calculations/4/results/5
```

**Лучше:**
```
✅ Проще:
/calculations/4/results
```

---

### 4️⃣ Используй query параметры для фильтрации

**Для фильтрации, сортировки, пагинации:**

```
GET /projects?status=active           ← только активные
GET /projects?sort=created_at         ← сортировка по дате
GET /projects?limit=10&offset=20      ← пагинация
GET /projects?user_id=123             ← проекты пользователя
```

**Не создавай отдельные endpoints:**

```
❌ Плохо:
/projects/active
/projects/inactive
/projects/by-user/123

✅ Хорошо:
/projects?status=active
/projects?status=inactive
/projects?user_id=123
```

---

### 5️⃣ Версионируй API

**Когда меняешь API, сохраняй старую версию:**

```
/api/v1/projects      ← старая версия (работает)
/api/v2/projects      ← новая версия (с изменениями)
```

**Зачем:**
- Старые клиенты продолжают работать
- Можно обновлять клиентов постепенно

**Варианты версионирования:**

```
1. В URL:
   /api/v1/projects

2. В заголовке:
   Accept: application/vnd.api.v1+json

3. В query параметре:
   /api/projects?version=1
```

**Рекомендация:** В URL (самое простое и понятное).

---

### 6️⃣ Правильные HTTP статус коды

**Используй правильные коды для каждой ситуации:**

**Успех:**
```
200 OK              - Получение данных
201 Created         - Создание ресурса
204 No Content      - Удаление (нет тела ответа)
```

**Ошибки клиента:**
```
400 Bad Request     - Некорректный запрос
401 Unauthorized    - Не авторизован
403 Forbidden       - Нет прав доступа
404 Not Found       - Ресурс не найден
422 Unprocessable   - Валидация не прошла
```

**Ошибки сервера:**
```
500 Internal Error  - Ошибка на сервере
503 Unavailable     - Сервис недоступен
```

---

### 7️⃣ Возвращай полезную информацию

**При создании - верни созданный объект:**

```
POST /api/projects
Body: {"name": "My Project"}

Response: 201 Created
{
  "id": 124,
  "name": "My Project",
  "created_at": "2025-01-20T14:30:00Z",
  "owner_id": 456
}
```

**При ошибке - верни детали:**

```
Response: 422 Unprocessable Entity
{
  "error": "Validation failed",
  "details": {
    "lift": "Must be between 0 and 25",
    "duration": "Must be between 180 and 360"
  }
}
```

---

## 🎯 Примеры хорошего и плохого API дизайна

### ❌ Плохой API дизайн

```
GET /getAllProjects
GET /getProjectById?id=123
POST /createNewProject
GET /updateProject?id=123&name=New
POST /removeProject
GET /getProjectCams?projectId=123
POST /calculateCamProfile
```

**Проблемы:**
- Глаголы в URL
- Непредсказуемые методы (GET для удаления?)
- Нет единообразия
- Query параметры везде

---

### ✅ Хороший REST API дизайн

```
GET    /api/projects              - Список проектов
GET    /api/projects/123          - Один проект
POST   /api/projects              - Создать проект
PUT    /api/projects/123          - Обновить проект
DELETE /api/projects/123          - Удалить проект

GET    /api/projects/123/cams     - Кулачки проекта
POST   /api/projects/123/cams     - Добавить кулачок
GET    /api/cams/456              - Один кулачок
PUT    /api/cams/456              - Обновить кулачок
DELETE /api/cams/456              - Удалить кулачок

POST   /api/cams/456/calculate    - Рассчитать профиль
```

**Преимущества:**
- ✅ Существительные в URL
- ✅ HTTP методы показывают действие
- ✅ Единообразие
- ✅ Понятная иерархия
- ✅ Предсказуемая структура

---

## 🔍 Query параметры (знак вопроса `?`)

### Что означает `?` в URL

**Знак вопроса `?`** разделяет **путь** и **параметры запроса** (query parameters).

```
GET /projects?user_id=123
          │   └─────────┘
          │    параметры
          │
       разделитель
```

**Полная структура URL:**

```
https://enginecampro.com/api/projects?user_id=123&status=active
└──┬──┘ └──────┬────────┘ └┬┘ └──┬───┘ └────────┬───────────┘
схема     домен            /   путь      query параметры
```

---

### Синтаксис query параметров

**Один параметр:**
```
?ключ=значение
```

**Пример:**
```
/projects?user_id=123
          │       │
          ключ    значение
```

**Несколько параметров** (разделяются символом `&`):
```
?ключ1=значение1&ключ2=значение2&ключ3=значение3
```

**Пример:**
```
/projects?user_id=123&status=active&sort=name
```

**Читается:** 
- user_id = 123
- status = active  
- sort = name

---

### 🏪 Аналогия: Фильтры в магазине

```
┌─────────────────────────────────────────────────────────┐
│                    ИНТЕРНЕТ-МАГАЗИН                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  /products                ← ВСЕ товары (1000 штук)     │
│                                                         │
│  Фильтры:                                               │
│  ☑ Цвет: красный                                        │
│  ☑ Размер: L                                            │
│  ☑ Бренд: Nike                                          │
│                                                         │
│  Результат: 15 товаров                                  │
│                                                         │
└─────────────────────────────────────────────────────────┘

В URL это выглядит так:
/products?color=red&size=L&brand=Nike
```

**Query параметры = фильтры в магазине!**

---

### Примеры использования

**1. Фильтрация по статусу:**
```
GET /projects?status=active

Значение: Только активные проекты
```

**2. Сортировка:**
```
GET /projects?sort=created_at

Значение: Отсортировать по дате создания
```

**3. Пагинация (постраничная навигация):**
```
GET /projects?limit=10&offset=20

Значение: 
- limit=10  → показать 10 проектов
- offset=20 → начиная с 21-го (пропустить первые 20)
```

**4. Множественные фильтры:**
```
GET /projects?user_id=123&status=active&sort=name&limit=5

Значение:
- user_id=123  → пользователь 123
- status=active → только активные
- sort=name → сортировать по имени
- limit=5 → максимум 5 результатов
```

**5. Поиск:**
```
GET /projects?search=engine

Значение: Поиск проектов со словом "engine" в названии
```

---

### Разница: Путь vs Query параметры

#### Путь (обязательная часть)

**Используется для:** Идентификации ресурса

```
/projects           ← коллекция проектов
/projects/123       ← конкретный проект #123
/projects/123/cams  ← кулачки проекта #123
```

**Это РАЗНЫЕ ресурсы!**

---

#### Query параметры (опциональная часть)

**Используются для:** Фильтрации, сортировки, опций

```
/projects                       ← все проекты
/projects?user_id=123           ← проекты пользователя 123
/projects?status=active         ← активные проекты
/projects?user_id=123&status=active ← оба фильтра
```

**Это ОДИН ресурс с разными фильтрами!**

---

### Когда что использовать?

#### ✅ Используй ПУТЬ когда:

**Идентифицируешь конкретный ресурс:**

```
GET /projects/123           ← проект #123 (конкретный)
GET /users/456              ← пользователь #456 (конкретный)
GET /cams/789               ← кулачок #789 (конкретный)
```

---

#### ✅ Используй QUERY ПАРАМЕТРЫ когда:

**Фильтруешь коллекцию:**
```
GET /projects?status=active              ← фильтр по статусу
GET /projects?user_id=123                ← фильтр по пользователю
```

**Сортируешь:**
```
GET /projects?sort=name                  ← сортировка
GET /projects?sort=created_at&order=desc ← сортировка + порядок
```

**Пагинация:**
```
GET /projects?page=2                     ← страница 2
GET /projects?limit=10&offset=20         ← лимит + смещение
```

**Поиск:**
```
GET /projects?search=engine              ← поиск по слову
GET /projects?name_contains=street       ← поиск в имени
```

---

### Важные правила

**1. Query параметры опциональны:**
```
GET /projects              ← работает (все проекты)
GET /projects?user_id=123  ← работает (фильтр применён)
```
Оба запроса валидны!

**2. Порядок параметров не важен:**
```
/projects?user_id=123&status=active
/projects?status=active&user_id=123
```
Эти URL делают ОДНО И ТО ЖЕ!

**3. Пробелы кодируются:**
```
Название: "My Project"
          └─ пробел

В URL: ?name=My%20Project
              └─ %20 = закодированный пробел
```

**Браузер делает это автоматически!**

---

### Как Backend читает query параметры

**В FastAPI:**

```python
@app.get("/api/projects")
async def get_projects(
    user_id: int = None,        # ?user_id=123
    status: str = None,         # ?status=active
    sort: str = None,           # ?sort=name
    limit: int = 10,            # ?limit=10
    offset: int = 0             # ?offset=0
):
    # Фильтрация по параметрам
    query = db.query(Project)
    
    if user_id:
        query = query.filter(Project.user_id == user_id)
    
    if status:
        query = query.filter(Project.status == status)
    
    if sort:
        query = query.order_by(getattr(Project, sort))
    
    # Пагинация
    projects = query.offset(offset).limit(limit).all()
    
    return projects
```

**Что происходит:**
1. FastAPI автоматически читает query параметры
2. Преобразует их в переменные Python
3. Ты используешь их для фильтрации данных

---

## 🏗️ Проектирование REST API для EngineCamPro

### Полная структура API

```
┌─────────────────────────────────────────────────────────┐
│              EngineCamPro REST API                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  АУТЕНТИФИКАЦИЯ                                         │
│  POST   /api/auth/register       - Регистрация         │
│  POST   /api/auth/login          - Вход                │
│  POST   /api/auth/logout         - Выход               │
│  GET    /api/auth/profile        - Мой профиль         │
│                                                         │
│  ПРОЕКТЫ                                                │
│  GET    /api/projects            - Все проекты         │
│  POST   /api/projects            - Создать проект      │
│  GET    /api/projects/123        - Один проект         │
│  PUT    /api/projects/123        - Обновить проект     │
│  PATCH  /api/projects/123        - Изменить поля       │
│  DELETE /api/projects/123        - Удалить проект      │
│                                                         │
│  КУЛАЧКИ                                                │
│  GET    /api/projects/123/cams   - Кулачки проекта     │
│  POST   /api/projects/123/cams   - Добавить кулачок    │
│  GET    /api/cams/456            - Один кулачок        │
│  PUT    /api/cams/456            - Обновить кулачок    │
│  PATCH  /api/cams/456            - Изменить параметры  │
│  DELETE /api/cams/456            - Удалить кулачок     │
│                                                         │
│  РАСЧЁТЫ                                                │
│  POST   /api/cams/456/calculate  - Рассчитать профиль  │
│  GET    /api/cams/456/profile    - Получить профиль    │
│  POST   /api/cams/456/export     - Экспорт данных      │
│                                                         │
│  ПОДПИСКИ                                               │
│  GET    /api/subscription        - Статус подписки     │
│  POST   /api/subscription/upgrade - Апгрейд           │
│  POST   /api/subscription/cancel  - Отмена            │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

### Примеры использования API

#### 1. Получить все проекты пользователя

```
GET /api/projects
Authorization: Bearer abc123xyz

Response: 200 OK
[
  {
    "id": 1,
    "name": "Street Engine",
    "cams_count": 2,
    "created_at": "2025-01-10"
  },
  {
    "id": 2,
    "name": "Race Engine",
    "cams_count": 4,
    "created_at": "2025-01-15"
  }
]
```

---

#### 2. Создать новый проект

```
POST /api/projects
Authorization: Bearer abc123xyz
Content-Type: application/json

{
  "name": "My New Project",
  "description": "High-performance street engine"
}

Response: 201 Created
{
  "id": 3,
  "name": "My New Project",
  "description": "High-performance street engine",
  "created_at": "2025-01-20T14:30:00Z",
  "owner_id": 456,
  "cams_count": 0
}
```

---

#### 3. Получить кулачки проекта

```
GET /api/projects/1/cams
Authorization: Bearer abc123xyz

Response: 200 OK
[
  {
    "id": 10,
    "name": "Intake Cam",
    "type": "intake",
    "lift": 11.5,
    "duration": 280
  },
  {
    "id": 11,
    "name": "Exhaust Cam",
    "type": "exhaust",
    "lift": 10.8,
    "duration": 270
  }
]
```

---

#### 4. Создать кулачок в проекте

```
POST /api/projects/1/cams
Authorization: Bearer abc123xyz
Content-Type: application/json

{
  "name": "Aggressive Street Cam",
  "type": "intake",
  "lift": 12.0,
  "duration": 290,
  "lobe_separation": 110
}

Response: 201 Created
{
  "id": 12,
  "project_id": 1,
  "name": "Aggressive Street Cam",
  "type": "intake",
  "lift": 12.0,
  "duration": 290,
  "lobe_separation": 110,
  "created_at": "2025-01-20T14:35:00Z"
}
```

---

#### 5. Рассчитать профиль кулачка

```
POST /api/cams/12/calculate
Authorization: Bearer abc123xyz

Response: 200 OK
{
  "cam_id": 12,
  "calculated_at": "2025-01-20T14:40:00Z",
  "profile": {
    "points": [
      {"angle": 0, "lift": 0.0},
      {"angle": 10, "lift": 0.5},
      {"angle": 20, "lift": 1.2}
    ],
    "max_velocity": 0.0234,
    "max_acceleration": 0.0012
  }
}
```

---

#### 6. Обработка ошибок

**Ресурс не найден:**
```
GET /api/projects/999
Authorization: Bearer abc123xyz

Response: 404 Not Found
{
  "error": "Project not found",
  "message": "Project with ID 999 does not exist"
}
```

**Валидация не прошла:**
```
POST /api/projects/1/cams
Authorization: Bearer abc123xyz

{
  "name": "Bad Cam",
  "lift": -5,           ← отрицательное значение
  "duration": 500       ← слишком большое
}

Response: 422 Unprocessable Entity
{
  "error": "Validation failed",
  "details": {
    "lift": "Must be between 0 and 25",
    "duration": "Must be between 180 and 360"
  }
}
```

**Нет прав доступа:**
```
DELETE /api/projects/1
Authorization: Bearer abc123xyz

Response: 403 Forbidden
{
  "error": "Permission denied",
  "message": "You don't have permission to delete this project"
}
```

---

## 🔗 Связь со всеми уроками модуля

### Полная картина Client-Server коммуникации

```
┌─────────────────────────────────────────────────────────┐
│  УРОК 1.1: Client-Server                                │
│  ┌──────────┐              ┌──────────┐                 │
│  │  Client  │ ◄────────►   │  Server  │                 │
│  └──────────┘              └──────────┘                 │
│       │                          │                       │
│       └──────────────┬───────────┘                       │
│                      │                                   │
├──────────────────────┼───────────────────────────────────┤
│  УРОК 1.2: HTTP      │                                   │
│                      │                                   │
│  GET /api/projects   │   HTTP Request                    │
│  Authorization: ...  │   • Метод (GET, POST...)          │
│                      │   • URL (/api/projects)           │
│                      │   • Заголовки                     │
│                      │   • Тело (опционально)            │
│                      │                                   │
│  Response: 200 OK    │   HTTP Response                   │
│  Content-Type: json  │   • Статус код (200, 404...)      │
│  [...]               │   • Заголовки                     │
│                      │   • Тело (данные)                 │
│                      │                                   │
├──────────────────────┼───────────────────────────────────┤
│  УРОК 1.3: JSON      │                                   │
│                      │                                   │
│  Request Body:       │   Формат данных                   │
│  {                   │   • Объекты {}                    │
│    "name": "..."     │   • Массивы []                    │
│  }                   │   • Типы: String, Number, etc     │
│                      │                                   │
│  Response Body:      │                                   │
│  {                   │                                   │
│    "id": 123,        │                                   │
│    "name": "..."     │                                   │
│  }                   │                                   │
│                      │                                   │
├──────────────────────┼───────────────────────────────────┤
│  УРОК 1.4: REST API  │                                   │
│                      │                                   │
│  Правила дизайна:    │   REST принципы                   │
│  • Существительные   │   • Stateless                     │
│  • HTTP методы       │   • Cacheable                     │
│  • Иерархия          │   • Uniform Interface             │
│  • Версионирование   │   • Client-Server                 │
│                      │                                   │
└──────────────────────┴───────────────────────────────────┘

         ВСЁ ВМЕСТЕ = REST API приложение!
```

**Теперь ты понимаешь:**
- ✅ **КТО** общается: Client и Server (урок 1.1)
- ✅ **КАК** общаются: По HTTP протоколу (урок 1.2)
- ✅ **ЧТО** передают: JSON данные (урок 1.3)
- ✅ **ПО КАКИМ ПРАВИЛАМ**: REST принципы (урок 1.4)

---

## 📝 Ключевые термины

### REST (Representational State Transfer)
**Что:** Архитектурный стиль для построения API  
**Зачем:** Единые правила, предсказуемость, простота использования  
**Не является:** Технологией или протоколом

### Ресурс (Resource)
**Что:** Объект или коллекция в системе  
**Примеры:** Проект, кулачок, пользователь  
**URL:** `/api/projects`, `/api/cams`

### Endpoint
**Что:** Конкретный адрес в API для операции  
**Примеры:** `GET /api/projects`, `POST /api/cams/123/calculate`  
**Состоит из:** HTTP метод + URL

### Idempotent (Идемпотентность)
**Что:** Можно повторять запрос - результат одинаковый  
**Идемпотентные:** GET, PUT, DELETE  
**Не идемпотентные:** POST (создаст дубликат)

### CRUD
**Что:** Create, Read, Update, Delete - базовые операции  
**Соответствие:** POST, GET, PUT/PATCH, DELETE  
**Аналогия:** Операции с данными в любой системе

---

## ✅ Критерии завершения урока

Отметь когда выполнено:

- [ ] **Понимание REST**
  - Могу объяснить что такое REST
  - Понимаю зачем нужны правила для API
  - Знаю 6 принципов REST (хотя бы основные 4)

- [ ] **Best Practices**
  - Знаю: существительные, не глаголы
  - Знаю: множественное число для коллекций
  - Знаю: иерархия для связанных ресурсов
  - Знаю: query параметры для фильтрации

- [ ] **Хороший vs плохой API**
  - Могу отличить хороший дизайн от плохого
  - Понимаю почему `/getProject` - плохо
  - Понимаю почему `GET /api/projects` - хорошо

- [ ] **EngineCamPro API**
  - Понимаю как будет устроен API проекта
  - Могу описать основные endpoints
  - Вижу структуру: проекты → кулачки → расчёты

- [ ] **Полная картина**
  - Понимаю как связаны все 4 урока
  - Вижу полный цикл: Client → HTTP → JSON → REST → Server
  - Готов к практике (Milestone 1)

- [ ] **Документирование**
  - Записал ключевые моменты в `notes/insights.md`
  - Если были вопросы - записал в `notes/questions.md`
  - Отметил завершение модуля 1 в roadmap

---

## 📝 Вопросы для самопроверки

Ответь на эти вопросы (устно или письменно):

1. **Что такое REST?**
   - Технология или набор правил?
   - Зачем нужны эти правила?
   - Какая аналогия с "правилами дорожного движения"?

2. **Принципы REST:**
   - Что означает Stateless?
   - Почему это важно?
   - Что означает Client-Server разделение?

3. **Best Practices:**
   - Почему `/getProjects` - плохо?
   - Почему `GET /api/projects` - хорошо?
   - Когда использовать `PUT` vs `PATCH`?
   - Зачем версионировать API?

4. **URL дизайн:**
   - Как показать что кулачок принадлежит проекту?
   - Где использовать query параметры?
   - Множественное или единственное число для ресурсов?

5. **Для EngineCamPro:**
   - Как получить все проекты?
   - Как создать новый кулачок?
   - Как запустить расчёт профиля?
   - Какие статус коды для успеха и ошибок?

6. **Полная картина:**
   - Как связаны все 4 урока модуля?
   - Что происходит когда отправляешь `POST /api/projects`?
   - Какой HTTP метод, какой JSON, какие правила REST?

---

## 🎯 Что дальше?

**Модуль 1 завершён!** 🎉

**Ты теперь понимаешь:**
- ✅ Client-Server архитектуру
- ✅ HTTP протокол
- ✅ JSON формат
- ✅ REST API принципы

**Следующий шаг: Практика!**

### 📦 Milestone 1: Создание простого API

**После завершения модуля 1 переходи к:**

`practice/milestone-1/`

**Там ты:**
1. Создашь настоящий FastAPI сервер
2. Реализуешь несколько REST endpoints
3. Примёнишь все изученные концепции
4. Протестируешь через Swagger
5. Поймёшь как всё работает на практике

**Теперь у тебя есть ВСЯ теория!**  
Все термины из практики (endpoint, JSON, HTTP методы) уже изучены.  
Можно уверенно переходить к коду! 🚀

---

## 💡 Итоговые выводы

**Что я понял из этого урока:**

1. **REST - это правила для API**:
   - Не технология, а архитектурный стиль
   - Делает API предсказуемым и понятным
   - Любой разработчик сразу понимает как пользоваться

2. **6 принципов REST**:
   - Client-Server (разделение)
   - Stateless (без состояния)
   - Cacheable (кэшируемость)
   - Uniform Interface (единообразие) ← самый важный!
   - Layered System (слои)
   - Code on Demand (опционально)

3. **Best Practices**:
   - Существительные в URL, не глаголы
   - HTTP метод показывает действие
   - Множественное число для коллекций
   - Иерархия для связей
   - Query параметры для фильтрации

4. **Полная картина веб-приложения**:
   - Client и Server общаются по HTTP
   - Передают JSON данные
   - Следуют REST правилам
   - Получается предсказуемый API

5. **Для EngineCamPro v2**:
   - Чёткая структура API
   - Понятные endpoints
   - Правильные HTTP методы и коды
   - Готов проектировать и реализовывать

---

**Статус урока:** ⏳ Не начат / 🔄 В процессе / ✅ Завершён  
**Дата начала:** _________  
**Дата завершения:** _________  
**Время изучения:** _________ минут

---

**🎉 МОДУЛЬ 1 ЗАВЕРШЁН! 🎉**

Теперь переходи к `practice/milestone-1/` для практики!

---

*Версия урока: 1.0*  
*Дата создания: 10 октября 2025*
