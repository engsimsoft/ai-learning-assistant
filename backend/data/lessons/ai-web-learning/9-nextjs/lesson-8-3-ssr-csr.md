# Урок 8.3: SSR vs CSR — Рендеринг на сервере и клиенте

> **Модуль 8:** Next.js Full-Stack (опциональный)  
> **Урок:** 8.3  
> **Длительность:** 50-60 минут  
> **Prerequisite:** Уроки 8.0, 8.1, 8.2

---

## 🎯 Цели урока

После этого урока ты сможешь:
- ✅ Понимать что такое рендеринг (rendering)
- ✅ Знать разницу между CSR и SSR
- ✅ Понимать что такое Hydration (гидратация)
- ✅ Знать про Server Components и Client Components
- ✅ Понимать когда нужен SSR, когда CSR достаточно
- ✅ Понимать почему для EngineCamPro выбран CSR

---

## 📖 Основные концепции

### Главный вопрос урока

**"Где создаётся HTML для пользователя?"**

### Простое определение

**Рендеринг (Rendering)** = процесс превращения данных + кода в HTML, который видит пользователь.

**Два места где может происходить рендеринг:**
1. **Server (сервер)** = SSR (Server-Side Rendering)
2. **Client (браузер)** = CSR (Client-Side Rendering)

---

## 🖥️ Часть 1: Client-Side Rendering (CSR) — что ты уже знаешь

### Что такое CSR?

**Простое определение:**
CSR = HTML создаётся в браузере пользователя с помощью JavaScript.

### Как работает CSR (React из Модуля 4)

```
┌────────────────────────────────────────────────────────┐
│         CLIENT-SIDE RENDERING (React)                  │
├────────────────────────────────────────────────────────┤
│                                                        │
│  1. Браузер → GET /                                    │
│     ↓                                                  │
│  2. Сервер возвращает пустой HTML + JavaScript        │
│     ↓                                                  │
│  3. Браузер загружает JavaScript (React)              │
│     ↓                                                  │
│  4. React выполняется в браузере                      │
│     ↓                                                  │
│  5. React создаёт HTML (рендерит компоненты)          │
│     ↓                                                  │
│  6. React добавляет HTML в DOM                        │
│     ↓                                                  │
│  7. Пользователь видит страницу                       │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### Пример: что возвращает сервер при CSR

**Запрос:**
```
GET https://enginecampro.vercel.app/
```

**Response (пустой HTML):**
```html
<!DOCTYPE html>
<html>
  <head>
    <title>EngineCamPro</title>
  </head>
  <body>
    <!-- Пустой div! -->
    <div id="root"></div>
    
    <!-- JavaScript загрузит React и заполнит root -->
    <script src="/static/js/main.js"></script>
  </body>
</html>
```

**Что делает браузер:**
```javascript
// main.js (упрощённо)
import React from 'react'
import ReactDOM from 'react-dom'
import App from './App'

// React создаёт HTML и вставляет в #root
ReactDOM.render(<App />, document.getElementById('root'))
```

**Результат в браузере (после выполнения JS):**
```html
<div id="root">
  <div class="app">
    <h1>Welcome to EngineCamPro</h1>
    <p>Calculate cam profiles...</p>
  </div>
</div>
```

### Временная диаграмма CSR

```
Время →

0ms    ┌─────────────┐
       │ GET /       │
       └──────┬──────┘
              ↓
50ms   ┌─────────────────────────────┐
       │ HTML (пустой) + JS bundle   │
       └──────┬──────────────────────┘
              ↓
100ms  ┌──────────────────────┐
       │ Загрузка JavaScript  │  ← Белый экран
       └──────┬───────────────┘
              ↓
500ms  ┌───────────────────────┐
       │ React парсит и        │  ← Белый экран
       │ компилирует компоненты│
       └──────┬────────────────┘
              ↓
800ms  ┌─────────────────┐
       │ React рендерит  │
       │ создаёт HTML    │
       └──────┬──────────┘
              ↓
1000ms ┌────────────────────────┐
       │ Пользователь видит UI  │  ✅ Контент появился
       └────────────────────────┘
```

**Важно:** Пользователь видит контент через **~1 секунду**!

### Плюсы CSR (React)

✅ **1. Простота**
- Один сервер (просто отдаёт файлы)
- Не нужна серверная логика

✅ **2. Интерактивность мгновенная**
- После загрузки всё работает без задержек
- Навигация между страницами без перезагрузки

✅ **3. Дешёвый хостинг**
- Можно деплоить на Vercel/Netlify бесплатно
- Статические файлы (HTML + JS)

✅ **4. Работает офлайн (с Service Workers)**

### Минусы CSR (React)

❌ **1. Плохой SEO (поисковая оптимизация)**
```
Google bot → GET / → Получает пустой HTML
           → Не видит контент
           → Не индексирует страницу
```

❌ **2. Медленная первая загрузка**
- Нужно загрузить весь JavaScript
- Только потом React создаст HTML
- Пользователь видит белый экран ~1 секунду

❌ **3. Медленно на слабых устройствах**
- React выполняется на устройстве пользователя
- Старые телефоны = медленно

❌ **4. Плохая социальная расшаривание**
```
Facebook/Twitter → GET / → Пустой HTML
                 → Не видят заголовок/картинку
                 → Плохая preview card
```

---

## 🌐 Часть 2: Server-Side Rendering (SSR) — Next.js подход

### Что такое SSR?

**Простое определение:**
SSR = HTML создаётся на сервере, браузер получает готовую страницу.

### Как работает SSR (Next.js)

```
┌────────────────────────────────────────────────────────┐
│         SERVER-SIDE RENDERING (Next.js)                │
├────────────────────────────────────────────────────────┤
│                                                        │
│  1. Браузер → GET /                                    │
│     ↓                                                  │
│  2. Next.js сервер:                                    │
│     - Выполняет React на сервере                      │
│     - Получает данные из БД                           │
│     - Рендерит компоненты в HTML                      │
│     ↓                                                  │
│  3. Сервер возвращает ГОТОВЫЙ HTML                    │
│     ↓                                                  │
│  4. Браузер отображает HTML сразу                     │
│     ↓                                                  │
│  5. Загружается JavaScript (для интерактивности)      │
│     ↓                                                  │
│  6. Hydration - JS "оживляет" HTML                    │
│     ↓                                                  │
│  7. Страница полностью интерактивна                   │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### Пример: что возвращает сервер при SSR

**Запрос:**
```
GET https://my-blog.vercel.app/posts/hello-world
```

**Response (ГОТОВЫЙ HTML):**
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Hello World - My Blog</title>
    <meta name="description" content="My first blog post">
  </head>
  <body>
    <!-- Готовый контент! -->
    <div id="__next">
      <article>
        <h1>Hello World</h1>
        <p>This is my first blog post...</p>
        <img src="/images/cover.jpg" alt="Cover">
      </article>
    </div>
    
    <!-- JavaScript для интерактивности загрузится позже -->
    <script src="/_next/static/chunks/main.js"></script>
  </body>
</html>
```

**Ключевое:** Браузер сразу видит контент! Не нужно ждать JavaScript.

### Временная диаграмма SSR

```
Время →

0ms    ┌─────────────┐
       │ GET /posts/1│
       └──────┬──────┘
              ↓
50ms   ┌──────────────────────┐
       │ Next.js на сервере:  │
       │ - Получает данные    │
       │ - Рендерит React     │
       │ - Создаёт HTML       │
       └──────┬───────────────┘
              ↓
200ms  ┌────────────────────────┐
       │ ГОТОВЫЙ HTML           │  ✅ Пользователь видит контент!
       └──────┬─────────────────┘
              ↓
400ms  ┌──────────────────────┐
       │ Загрузка JavaScript  │  (страница уже видна)
       └──────┬───────────────┘
              ↓
600ms  ┌─────────────────────┐
       │ Hydration            │  ✅ Страница интерактивна
       │ (оживление HTML)     │
       └──────────────────────┘
```

**Важно:** Пользователь видит контент через **~200ms** (в 5 раз быстрее CSR)!

### Плюсы SSR (Next.js)

✅ **1. Отличный SEO**
```
Google bot → GET / → Получает готовый HTML
           → Видит весь контент
           → Индексирует правильно
```

✅ **2. Быстрая первая загрузка**
- HTML готов на сервере
- Пользователь видит контент сразу
- Не нужно ждать JavaScript

✅ **3. Социальные сети**
```
Facebook → GET /posts/1 → Видит заголовок, описание, картинку
         → Красивая preview card
```

✅ **4. Быстро на слабых устройствах**
- Тяжёлая работа на сервере (мощный)
- Браузер получает готовый HTML

### Минусы SSR (Next.js)

❌ **1. Сложнее разработка**
- Нужно думать: "Где выполняется этот код?"
- `window`, `document` не доступны на сервере

❌ **2. Дороже хостинг**
- Нужен сервер (Node.js)
- Нельзя просто отдавать статические файлы

❌ **3. Медленнее Time To Interactive (TTI)**
- HTML появляется быстро
- Но кнопки не работают пока не загрузится JS

❌ **4. Нагрузка на сервер**
- Каждый запрос = рендеринг на сервере
- Нужно масштабировать сервер

---

## 🏗️ Часть 3: Static Site Generation (SSG) — гибрид

### Что такое SSG?

**Простое определение:**
SSG = HTML создаётся один раз при сборке (build time), затем просто отдаётся как статический файл.

### Как работает SSG (Next.js)

```
┌────────────────────────────────────────────────────────┐
│      STATIC SITE GENERATION (Next.js SSG)              │
├────────────────────────────────────────────────────────┤
│                                                        │
│  BUILD TIME (один раз):                                │
│  1. npm run build                                      │
│     ↓                                                  │
│  2. Next.js для каждой страницы:                       │
│     - Получает данные                                 │
│     - Рендерит React в HTML                           │
│     - Сохраняет HTML файл                             │
│     ↓                                                  │
│  3. Результат: статические HTML файлы                 │
│                                                        │
│  REQUEST TIME (каждый запрос):                         │
│  1. Браузер → GET /posts/hello                        │
│     ↓                                                  │
│  2. CDN возвращает готовый HTML (мгновенно!)          │
│     ↓                                                  │
│  3. Пользователь видит страницу                       │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### Пример: Next.js SSG

**Код страницы:**
```typescript
// app/posts/[id]/page.tsx
export async function generateStaticParams() {
  // Next.js вызовет это при сборке
  const posts = await db.posts.findMany()
  
  // Генерируем HTML для каждого поста
  return posts.map(post => ({
    id: post.id.toString()
  }))
}

export default async function PostPage({ params }) {
  const post = await db.posts.findUnique({
    where: { id: params.id }
  })
  
  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  )
}
```

**Сборка:**
```bash
$ npm run build

Building pages:
  ✓ /
  ✓ /posts/1  → .next/server/pages/posts/1.html
  ✓ /posts/2  → .next/server/pages/posts/2.html
  ✓ /posts/3  → .next/server/pages/posts/3.html

Build complete!
```

**Результат:**
- 3 готовых HTML файла
- Можно деплоить на CDN (очень быстро!)
- Нет нагрузки на сервер при запросах

### Временная диаграмма SSG

```
Время →

0ms    ┌─────────────┐
       │ GET /posts/1│
       └──────┬──────┘
              ↓
10ms   ┌────────────────────────┐
       │ CDN возвращает HTML    │  ✅ Мгновенно!
       └──────┬─────────────────┘
              ↓
50ms   ┌────────────────────────┐
       │ Пользователь видит всё │  ✅ Контент виден
       └──────┬─────────────────┘
              ↓
200ms  ┌──────────────────────┐
       │ Загрузка JavaScript  │
       └──────┬───────────────┘
              ↓
400ms  ┌─────────────────────┐
       │ Hydration            │  ✅ Интерактивность
       └──────────────────────┘
```

**Важно:** Быстрее чем SSR! Потому что HTML уже готов.

### Когда использовать SSG

✅ **Идеально для:**
- Блоги (контент меняется редко)
- Документация
- Маркетинговые сайты
- Портфолио

❌ **НЕ подходит для:**
- Персонализированный контент (для каждого пользователя свой)
- Часто меняющиеся данные (каждую минуту)
- Приложения с аутентификацией

---

## 💧 Часть 4: Hydration (Гидратация) — оживление HTML

### Что такое Hydration?

**Простое определение:**
Hydration = процесс "оживления" статического HTML, делая его интерактивным.

**Метафора:**
```
Сервер отправил "сухой" HTML (просто текст)
                  ↓
Браузер "поливает" его JavaScript (гидратация)
                  ↓
HTML "оживает" - кнопки работают, всё интерактивно!
```

### Как работает Hydration

#### 1. Сервер отправляет HTML

```html
<!-- Готовый HTML с сервера -->
<button id="like-btn">
  👍 Like (42)
</button>
```

**Проблема:** Кнопка видна, но НЕ работает! Нет обработчика `onClick`.

#### 2. Браузер загружает JavaScript

```javascript
// React code
function LikeButton() {
  const [likes, setLikes] = useState(42)
  
  function handleClick() {
    setLikes(likes + 1)
  }
  
  return <button onClick={handleClick}>👍 Like ({likes})</button>
}
```

#### 3. React делает Hydration

```
React смотрит на HTML:
  - Находит <button>
  - Понимает: "Это мой LikeButton компонент"
  - Прикрепляет обработчик onClick
  - Инициализирует state (likes = 42)
  ↓
Теперь кнопка РАБОТАЕТ!
```

### Визуальная диаграмма Hydration

```
┌─────────────────────────────────────────────────────┐
│              HYDRATION ПРОЦЕСС                      │
├─────────────────────────────────────────────────────┤
│                                                     │
│  Server отправил HTML:                              │
│  ┌──────────────────────┐                          │
│  │  <button>            │  ← Виден, но не работает │
│  │    👍 Like (42)      │                          │
│  │  </button>           │                          │
│  └──────────────────────┘                          │
│           ↓                                         │
│  JavaScript загружен                                │
│           ↓                                         │
│  React делает Hydration:                            │
│  ┌──────────────────────┐                          │
│  │  <button             │  ← Теперь интерактивна! │
│  │    onClick={...}     │                          │
│  │  >                   │                          │
│  │    👍 Like (42)      │                          │
│  │  </button>           │                          │
│  └──────────────────────┘                          │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### Hydration в Next.js

**Next.js делает Hydration автоматически!**

```typescript
// app/page.tsx (Server Component по умолчанию)
export default function HomePage() {
  return (
    <div>
      <h1>Welcome</h1>
      <LikeButton />  {/* Client Component */}
    </div>
  )
}

// components/LikeButton.tsx
'use client'  // ← Этот компонент нужен в браузере

import { useState } from 'react'

export default function LikeButton() {
  const [likes, setLikes] = useState(0)
  
  return (
    <button onClick={() => setLikes(likes + 1)}>
      👍 {likes}
    </button>
  )
}
```

**Что происходит:**
1. Next.js рендерит всё на сервере → HTML
2. Браузер получает HTML (видит кнопку)
3. JavaScript загружается
4. React делает Hydration для `<LikeButton />` (прикрепляет onClick)
5. Кнопка работает!

---

## 🧩 Часть 5: Server Components vs Client Components

### Что такое Server Components?

**Новая фича Next.js 13+:**
- Компоненты которые рендерятся ТОЛЬКО на сервере
- JavaScript этих компонентов НЕ отправляется в браузер
- Уменьшает размер JavaScript bundle

### Сравнение

| **Аспект** | **Server Component** | **Client Component** |
|---|---|---|
| **Где рендерится** | Только на сервере | Сервер + браузер |
| **JS в браузер** | Нет | Да |
| **Может использовать** | Hooks ❌, Database ✅ | Hooks ✅, Database ❌ |
| **Интерактивность** | Нет (статический HTML) | Да |
| **По умолчанию** | Да (в Next.js 13+) | Нет |
| **Директива** | Нет (по умолчанию) | `'use client'` |

### Пример: Server Component

```typescript
// app/posts/page.tsx (Server Component по умолчанию)
import { db } from '@/lib/db'

// НЕТ 'use client' = Server Component
export default async function PostsPage() {
  // Можем использовать БД напрямую!
  const posts = await db.posts.findMany()
  
  // Этот компонент отрендерится на сервере
  // JavaScript не попадёт в браузер
  return (
    <div>
      <h1>All Posts</h1>
      <ul>
        {posts.map(post => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </div>
  )
}
```

**Плюсы:**
- ✅ Меньше JavaScript в браузере
- ✅ Можно использовать БД напрямую
- ✅ Безопасность (API ключи не попадают в браузер)

**Минусы:**
- ❌ Нет интерактивности (нет onClick, useState)

### Пример: Client Component

```typescript
// components/LikeButton.tsx
'use client'  // ← Client Component

import { useState } from 'react'

export default function LikeButton() {
  // Можем использовать hooks!
  const [likes, setLikes] = useState(0)
  
  // Этот компонент попадёт в браузер
  // Будет интерактивным
  return (
    <button onClick={() => setLikes(likes + 1)}>
      👍 {likes}
    </button>
  )
}
```

**Плюсы:**
- ✅ Полная интерактивность
- ✅ Hooks работают
- ✅ Event listeners (onClick, onChange)

**Минусы:**
- ❌ JavaScript попадает в браузер (больше bundle)
- ❌ Нельзя использовать БД напрямую

### Гибридный подход (Best Practice)

```typescript
// app/posts/[id]/page.tsx (Server Component)
import { db } from '@/lib/db'
import LikeButton from '@/components/LikeButton'  // Client Component

export default async function PostPage({ params }) {
  // Получаем данные на сервере
  const post = await db.posts.findUnique({
    where: { id: params.id }
  })
  
  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
      
      {/* Client Component для интерактивности */}
      <LikeButton postId={post.id} initialLikes={post.likes} />
    </article>
  )
}
```

**Результат:**
- ✅ Большая часть страницы = Server Component (меньше JS)
- ✅ Только кнопка = Client Component (интерактивность)
- ✅ Лучшее из двух миров!

---

## 📊 Итоговая таблица сравнения

| **Подход** | **CSR (React)** | **SSR (Next.js)** | **SSG (Next.js)** |
|---|---|---|---|
| **HTML создаётся** | В браузере | На сервере (каждый запрос) | При сборке (один раз) |
| **Первая загрузка** | Медленно (~1s) | Быстро (~200ms) | Очень быстро (~50ms) |
| **SEO** | Плохой ❌ | Отличный ✅ | Отличный ✅ |
| **Интерактивность** | Сразу после загрузки | После Hydration | После Hydration |
| **Хостинг** | Дешёвый (статика) | Дорогой (Node.js) | Дешёвый (CDN) |
| **Персонализация** | Легко | Легко | Сложно |
| **Для блога** | ❌ | ✅ | ✅ (лучший) |
| **Для EngineCamPro** | ✅ (достаточно) | ⚠️ (излишне) | ❌ (не подходит) |
| **Для dashboard** | ✅ | ✅ | ❌ |

---

## 🎯 Когда использовать каждый подход

### Используй CSR (React) когда:

✅ **1. SEO не важен**
```
Dashboard, админка, внутренние инструменты
```

✅ **2. Контент за логином**
```
Приложение требует авторизации → поисковики не индексируют
```

✅ **3. Много интерактивности**
```
Калькуляторы, редакторы, игры
```

✅ **4. Данные меняются часто**
```
Real-time данные, WebSockets
```

✅ **5. Простота важнее SEO**
```
MVP, прототип, внутренний инструмент
```

**Пример: EngineCamPro**
- Dashboard для инженеров ✅
- За логином (Clerk) ✅
- Интерактивные графики ✅
- SEO не критичен ✅
- → **CSR (React) идеально!**

---

### Используй SSR (Next.js) когда:

✅ **1. SEO критичен**
```
E-commerce, новостной сайт, блог
```

✅ **2. Персонализированный контент**
```
Для каждого пользователя свой контент
```

✅ **3. Часто меняющиеся данные**
```
Котировки акций, спортивные результаты
```

✅ **4. Социальные расшаривания**
```
Важны Open Graph preview cards
```

**Пример: Интернет-магазин**
- SEO критичен (Google) ✅
- Open Graph для Facebook ✅
- Персональные рекомендации ✅
- → **SSR идеально!**

---

### Используй SSG (Next.js) когда:

✅ **1. Контент меняется редко**
```
Блог (раз в день), документация
```

✅ **2. SEO критичен + скорость важна**
```
Маркетинговый сайт, landing page
```

✅ **3. Нет персонализации**
```
Все видят одинаковый контент
```

✅ **4. Максимальная производительность**
```
Миллионы пользователей → CDN
```

**Пример: Документация**
- Контент статический ✅
- SEO важен ✅
- Скорость критична ✅
- → **SSG идеально!**

---

## 💡 Практический пример: Блог на разных подходах

### CSR (React)

**Проблема:**
```
Google bot → GET /posts/hello-world
           → Получает пустой <div id="root"></div>
           → Не видит заголовок, контент
           → Не индексирует ❌
```

### SSR (Next.js)

**Решение:**
```typescript
// app/posts/[slug]/page.tsx
export default async function PostPage({ params }) {
  const post = await db.posts.findUnique({
    where: { slug: params.slug }
  })
  
  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  )
}
```

**Результат:**
```
Google bot → GET /posts/hello-world
           → Получает готовый HTML с контентом
           → Видит заголовок, текст
           → Индексирует правильно ✅
```

**Но:** Каждый запрос = рендеринг на сервере (нагрузка)

### SSG (Next.js) — лучший выбор для блога

**Решение:**
```typescript
// app/posts/[slug]/page.tsx
export async function generateStaticParams() {
  const posts = await db.posts.findMany()
  return posts.map(post => ({ slug: post.slug }))
}

export default async function PostPage({ params }) {
  const post = await db.posts.findUnique({
    where: { slug: params.slug }
  })
  
  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  )
}
```

**Результат:**
- HTML создаётся один раз при `npm run build`
- Каждый запрос = мгновенная отдача HTML
- SEO отличный ✅
- Скорость максимальная ✅
- Хостинг дешёвый (CDN) ✅

---

## 🎓 Резюме урока

### Ключевые различия

**CSR (Client-Side Rendering):**
```
✅ Простота
✅ Дешёвый хостинг
✅ Интерактивность
❌ Плохой SEO
❌ Медленная первая загрузка
→ Для: Dashboard, инструменты, приложения за логином
```

**SSR (Server-Side Rendering):**
```
✅ Отличный SEO
✅ Быстрая первая загрузка
✅ Социальные расшаривания
❌ Сложнее разработка
❌ Дороже хостинг
→ Для: E-commerce, новости, персонализация
```

**SSG (Static Site Generation):**
```
✅ Максимальная скорость
✅ Отличный SEO
✅ Дешёвый хостинг
❌ Не для динамического контента
❌ Пересборка для обновления
→ Для: Блоги, документация, маркетинг
```

### Для EngineCamPro

**CSR (React) выбран потому что:**
1. Dashboard за логином (SEO не нужен)
2. Интерактивные графики и расчёты
3. Данные персональные (для каждого пользователя свои)
4. Простота разработки важнее SEO
5. FastAPI Backend отдельно (лучше для математики)

**SSR не нужен потому что:**
- SEO не критичен (приложение за логином)
- Google не должен индексировать расчёты пользователей
- Излишняя сложность

---

## 📝 Проверка понимания

1. **Что такое CSR?**
   - Ответ: HTML создаётся в браузере с помощью JavaScript (React)

2. **Что такое SSR?**
   - Ответ: HTML создаётся на сервере для каждого запроса (Next.js)

3. **Что такое Hydration?**
   - Ответ: Процесс "оживления" статического HTML, делая его интерактивным

4. **Когда использовать CSR?**
   - Ответ: Dashboard, приложения за логином, SEO не важен, много интерактивности

5. **Когда использовать SSR?**
   - Ответ: SEO критичен, e-commerce, новости, социальные расшаривания

6. **Почему для EngineCamPro выбран CSR?**
   - Ответ: Dashboard за логином, SEO не нужен, интерактивность важнее

---

## 🚀 Следующий шаг

В **Уроке 8.4** (финальный урок модуля) мы сравним:
- **File-Based Routing** (Next.js)
- **React Router** (React из Модуля 4)
- App Router vs Pages Router
- Когда что использовать

**Готов завершить модуль?** 🎯

---

**Конец урока 8.3** ✅
