# 4.4 Database с Drizzle ORM

> **Время изучения:** 50-60 минут  
> **Сложность:** ⭐⭐ Критически важный урок  
> **Prerequisite:** Урок 1.7 (SSOT), Урок 4.3 (Структура папок), AI Web Learning Module 3 (Database basics)

---

## 🎯 Цель урока

Научиться **правильно работать** с PostgreSQL через Drizzle ORM в Express проекте. Мы разберём почему shared/schema.ts в 527 ShortCut - отличное решение, но использование `db:push` вместо миграций - критическая ошибка для production.

**Почему это критично:**  
`db:push` может УДАЛИТЬ данные в production БД. Миграции - единственный безопасный способ изменять схему БД.

---

## 🤔 Что такое ORM и зачем он нужен?

### Проблема: Работа с БД на чистом SQL сложна

```typescript
// ❌ Без ORM - пишем SQL вручную
const result = await db.query(`
  SELECT * FROM races 
  WHERE id = $1 
  AND status = $2
`, [raceId, 'completed']);

// Проблемы:
// - SQL строки (легко ошибиться)
// - Нет типов (TypeScript не знает структуру результата)
// - SQL injection риск
// - Сложно рефакторить
```

### Решение: ORM (Object-Relational Mapping)

```typescript
// ✅ С Drizzle ORM
const result = await db
  .select()
  .from(races)
  .where(eq(races.id, raceId))
  .where(eq(races.status, 'completed'));

// Преимущества:
// - TypeScript типы автоматически
// - SQL injection защита
// - Autocomplete в IDE
// - Легко рефакторить
```

**Аналогия:**  
ORM - это как переводчик между миром объектов (TypeScript) и миром таблиц (PostgreSQL). Ты говоришь на TypeScript, а ORM переводит это в SQL.

---

## 🔧 Drizzle ORM - современный выбор

### Почему Drizzle, а не Prisma или TypeORM?

| Фича | Drizzle ORM | Prisma | TypeORM |
|------|-------------|--------|---------|
| **TypeScript-first** | ✅ Родной TS | ✅ Да | ⚠️ Decorators |
| **Производительность** | ✅✅ Отлично | ⚠️ Медленнее | ⚠️ Медленнее |
| **SQL контроль** | ✅✅ Полный | ❌ Ограниченный | ⚠️ Средний |
| **Размер bundle** | ✅ Маленький | ❌ Большой | ❌ Огромный |
| **Миграции** | ✅ Есть | ✅ Есть | ✅ Есть |
| **Relational queries** | ✅ Удобно | ✅ Удобно | ⚠️ Сложно |

**Drizzle ORM идеален когда:**
- Нужен TypeScript-first подход
- Хочешь контроль над SQL
- Важна производительность
- PostgreSQL, MySQL или SQLite

**527 ShortCut использует Drizzle** - правильный выбор! ✅

---

## 📁 Schema организация: SSOT принцип

### Архитектура в 527 ShortCut (ОТЛИЧНО!)

```
project/
│
├── shared/
│   └── schema.ts          # ✅ Single Source of Truth!
│
├── server/
│   └── postgres-storage.ts    # Использует schema
│
└── client/
    └── src/
        └── types/          # Использует типы из schema
```

**Главная идея:**  
Database schema живёт в ОДНОМ файле, который видят и backend и frontend.

---

## ✅ ЧТО СДЕЛАНО ОТЛИЧНО: shared/schema.ts

### Пример из 527 ShortCut

```typescript
// shared/schema.ts - ОДИН файл для ВСЕГО проекта!

import { pgTable, serial, varchar, integer, date, boolean, text, timestamp } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

// Таблица гонок
export const races = pgTable('races', {
  id: serial('id').primaryKey(),
  name: varchar('name', { length: 255 }).notNull(),
  trackId: integer('track_id').references(() => tracks.id),
  startDate: date('start_date').notNull(),
  endDate: date('end_date').notNull(),
  status: varchar('status', { length: 50 }).notNull().default('upcoming'),
  season: varchar('season', { length: 10 }).notNull(),
  stageNumber: integer('stage_number').notNull(),
  imageUrl: text('image_url'),
  race1VideoUrl: text('race1_video_url'),
  race2VideoUrl: text('race2_video_url'),
});

// Таблица результатов
export const results = pgTable('results', {
  id: serial('id').primaryKey(),
  raceId: integer('race_id').references(() => races.id).notNull(),
  sessionType: varchar('session_type', { length: 50 }).notNull(),
  position: integer('position').notNull(),
  carNumber: integer('car_number').notNull(),
  driverName: varchar('driver_name', { length: 255 }).notNull(),
  teamName: varchar('team_name', { length: 255 }),
  time: varchar('time', { length: 50 }),
  bestLapTime: varchar('best_lap_time', { length: 50 }),
  totalLaps: integer('total_laps'),
  gapToLeader: varchar('gap_to_leader', { length: 50 }),
  points: integer('points').default(0),
  notClassified: boolean('not_classified').default(false),
  notClassifiedReason: varchar('not_classified_reason', { length: 255 }),
});

// Relations (связи между таблицами)
export const racesRelations = relations(races, ({ one, many }) => ({
  track: one(tracks, {
    fields: [races.trackId],
    references: [tracks.id],
  }),
  results: many(results),
}));

export const resultsRelations = relations(results, ({ one }) => ({
  race: one(races, {
    fields: [results.raceId],
    references: [races.id],
  }),
}));

// TypeScript типы генерируются автоматически!
export type Race = typeof races.$inferSelect;
export type NewRace = typeof races.$inferInsert;
export type Result = typeof results.$inferSelect;
export type NewResult = typeof results.$inferInsert;
```

### Почему это ГЕНИАЛЬНО? ✅

```
┌─────────────────────────────────────────────────────────────┐
│          ✅ ПРЕИМУЩЕСТВА shared/schema.ts                   │
└─────────────────────────────────────────────────────────────┘

1. SSOT (Single Source of Truth)
   ├── Схема БД описана в ОДНОМ месте
   ├── Нет дублирования между backend и frontend
   └── Изменения в одном месте = изменения везде

2. TypeScript типы автоматически
   ├── Drizzle генерирует типы из schema
   ├── Backend знает структуру таблиц
   ├── Frontend знает структуру данных
   └── Автокомплит в IDE работает везде!

3. Refactoring безопасный
   ├── Изменил название поля в schema
   ├── TypeScript покажет ВСЕ места где используется
   └── Не можешь забыть обновить где-то

4. Relations встроены
   ├── Описал связи один раз
   ├── Drizzle понимает как делать JOIN
   └── Легко получать связанные данные

5. Shared между проектами
   ├── Backend использует: import { races } from '@/shared/schema'
   ├── Frontend использует: import { Race } from '@/shared/schema'
   └── Один источник правды для всех
```

**Это ОБРАЗЕЦ правильной организации!** 👏

---

## 🔍 Как использовать schema в коде

### Backend: Queries с типами

```typescript
// server/postgres-storage.ts
import { db } from './db';
import { races, results, eq } from '@/shared/schema';

export class Storage {
  
  // Получить все гонки (типы автоматически!)
  async getAllRaces(): Promise<Race[]> {
    return await db.select().from(races);
  }
  
  // Получить гонку по ID
  async getRaceById(id: number): Promise<Race | null> {
    const [race] = await db
      .select()
      .from(races)
      .where(eq(races.id, id))
      .limit(1);
    
    return race || null;
  }
  
  // Получить результаты с информацией о гонке (JOIN)
  async getResultsWithRace(raceId: number) {
    return await db
      .select()
      .from(results)
      .leftJoin(races, eq(results.raceId, races.id))
      .where(eq(results.raceId, raceId));
  }
}
```

**Магия TypeScript:**
```typescript
const races = await storage.getAllRaces();

// TypeScript знает структуру!
races[0].name        // ✅ Автокомплит работает
races[0].trackId     // ✅ Знает что это number
races[0].wrongField  // ❌ TypeScript ошибка: нет такого поля
```

### Frontend: Типы из schema

```typescript
// client/src/pages/Results.tsx
import { Race, Result } from '@/shared/schema';
import { useState, useEffect } from 'react';

function ResultsPage() {
  const [races, setRaces] = useState<Race[]>([]);
  const [results, setResults] = useState<Result[]>([]);
  
  useEffect(() => {
    // Fetch data from API
    fetch('/api/races')
      .then(res => res.json())
      .then((data: Race[]) => setRaces(data));
  }, []);
  
  return (
    <div>
      {races.map(race => (
        <div key={race.id}>
          <h2>{race.name}</h2>
          {/* TypeScript знает все поля! */}
          <p>Stage: {race.stageNumber}</p>
          <p>Status: {race.status}</p>
        </div>
      ))}
    </div>
  );
}
```

**Преимущества:**
- ✅ Frontend и Backend используют одинаковые типы
- ✅ Изменил schema → оба проекта обновляются
- ✅ Нет расхождений между API и UI

---

## ❌ КРИТИЧЕСКАЯ ПРОБЛЕМА: db:push вместо миграций

### Что происходит в 527 ShortCut СЕЙЧАС

```json
// package.json
{
  "scripts": {
    "db:push": "drizzle-kit push",      // ❌ Используется!
    "db:generate": "drizzle-kit generate", // Не используется
    "db:migrate": "drizzle-kit migrate"    // Не используется
  }
}
```

**Как работает сейчас:**
```bash
# Разработчик изменил schema.ts
# Добавил новое поле в таблицу

npm run db:push  # ❌ Прямое изменение БД без миграции!
```

### Что такое db:push и почему это ОПАСНО?

**db:push:**
- Читает `schema.ts`
- Сравнивает с текущей БД
- **СРАЗУ применяет изменения** к БД (без истории)

```
┌─────────────────────────────────────────────────────────────┐
│          ❌ ПРОБЛЕМЫ db:push В PRODUCTION                   │
└─────────────────────────────────────────────────────────────┘

ПРОБЛЕМА 1: Потеря данных
├── db:push может УДАЛИТЬ столбец
├── Данные в этом столбце ПРОПАДУТ навсегда
└── 💀 НЕВОЗМОЖНО откатить!

ПРОБЛЕМА 2: Нет истории изменений
├── Не понятно КТО и КОГДА изменил схему
├── Нет контроля версий для БД
└── Невозможно понять что было до изменения

ПРОБЛЕМА 3: Проблемы в команде
├── Разработчик A запустил db:push локально
├── Разработчик B запустил db:push с другой схемой
├── Production БД: кто-то запустил db:push
└── 💥 Все БД разные! Хаос!

ПРОБЛЕМА 4: Невозможно откатить
├── db:push изменил БД
├── Что-то сломалось
├── Как вернуть назад?
└── ❌ НИКАК! Данные потеряны

ПРОБЛЕМА 5: CI/CD невозможен
├── Automated deployments не работают
├── Нужно вручную запускать db:push
└── Human error риск
```

---

### Реальный сценарий КАТАСТРОФЫ

**День 1: Разработка фичи**
```typescript
// Разработчик добавил поле в schema.ts
export const races = pgTable('races', {
  // ... существующие поля
  newFeatureData: text('new_feature_data'),  // Новое поле
});
```

```bash
npm run db:push  # Локально добавил поле - работает!
```

**День 2: Фича не нужна**
```typescript
// Разработчик УДАЛИЛ поле из schema.ts
export const races = pgTable('races', {
  // ... существующие поля
  // newFeatureData удалено
});
```

```bash
npm run db:push  # ❌ ОПАСНОСТЬ!
```

**ЧТО ПРОИЗОШЛО:**
```
Drizzle видит: поле newFeatureData нет в schema.ts
Drizzle делает: DROP COLUMN newFeatureData
Результат: 💀 ВСЕ ДАННЫЕ в этом столбце УДАЛЕНЫ навсегда!
```

**А если это production БД:**
```
Потеряны данные пользователей
Невозможно восстановить (нет backup точки)
Бизнес убытки
Репутация потеряна
```

---

### ЧЕМ ГРОЗИТ использование db:push в production?

```
┌─────────────────────────────────────────────────────────────┐
│          💰 ЦЕНА ОШИБКИ "db:push в production"              │
└─────────────────────────────────────────────────────────────┘

СЕЙЧАС (маленький проект, dev фаза):
├── Быстро и удобно
├── Нет истории БД, но не критично
└── ⚠️ Играете с огнём

ПЕРВЫЙ ИНЦИДЕНТ (случайно удалили столбец):
├── Потеря данных
├── Паника в команде
├── Попытки восстановить (если есть backup)
└── 💸 Минимум 1 день простоя + репутация

PRODUCTION С ПОЛЬЗОВАТЕЛЯМИ:
├── 💀 Удалили критический столбец
├── Приложение перестало работать
├── Данные пользователей потеряны
├── Невозможно откатить (нет миграций!)
└── 💸💸💸 Катастрофа:
    ├── Простой бизнеса
    ├── Потеря клиентов
    ├── Юридические проблемы (GDPR)
    └── Репутация убита

КОМАНДА > 1 ЧЕЛОВЕКА:
├── Разные версии схемы у разных разработчиков
├── Production отличается от всех
├── Невозможно синхронизировать
└── 💸 Недели на разбор проблем

ЦЕНА ИСПРАВЛЕНИЯ:
├── СЕЙЧАС: 1 день (внедрить миграции)
├── ПОСЛЕ ИНЦИДЕНТА: недели восстановления
└── МНОЖИТЕЛЬ: 50x-100x ущерба
```

**Вердикт:**  
`db:push` можно использовать ТОЛЬКО для **локальной разработки** в **одиночку**. В production - **НИКОГДА!**

---

## ✅ Правильное решение: Миграции

### Что такое миграции?

**Миграция** - это файл с SQL командами, который:
- Описывает КАК изменить схему БД
- Имеет версию (timestamp)
- Может быть откачен (rollback)
- Хранится в git (история изменений)

**Аналогия:**  
Миграции - это как git commits для базы данных. Каждое изменение схемы записывается в файл, можно посмотреть историю, откатить назад.

---

### Как работают миграции в Drizzle

```
┌─────────────────────────────────────────────────────────────┐
│              Workflow с миграциями                          │
└─────────────────────────────────────────────────────────────┘

ШАГ 1: Изменяем schema.ts
├── Добавили новое поле, таблицу, или изменили что-то
└── Файл: shared/schema.ts

ШАГ 2: Генерируем миграцию
├── Команда: npm run db:generate
├── Drizzle сравнивает schema.ts с последней миграцией
├── Создаёт SQL файл с изменениями
└── Файл: drizzle/0001_add_new_field.sql

ШАГ 3: Проверяем миграцию
├── Открываем сгенерированный SQL
├── Проверяем что изменения правильные
└── Можем отредактировать вручную (если нужно)

ШАГ 4: Применяем миграцию
├── Локально: npm run db:migrate
├── Production: npm run db:migrate (в CI/CD)
└── Drizzle запоминает какие миграции применены

ШАГ 5: Коммитим в git
├── schema.ts + миграция в одном commit
├── История изменений БД в git
└── Команда видит что изменилось
```

---

### Создание миграций в 527 ShortCut

#### 1. Настройка Drizzle Kit

```typescript
// drizzle.config.ts
import { defineConfig } from 'drizzle-kit';
import dotenv from 'dotenv';

dotenv.config();

export default defineConfig({
  schema: './shared/schema.ts',
  out: './drizzle',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
});
```

#### 2. Изменяем schema.ts

```typescript
// shared/schema.ts - добавляем новое поле
export const races = pgTable('races', {
  id: serial('id').primaryKey(),
  name: varchar('name', { length: 255 }).notNull(),
  // ... существующие поля
  
  // ✅ Новое поле
  sponsorName: varchar('sponsor_name', { length: 255 }),
});
```

#### 3. Генерируем миграцию

```bash
npm run db:generate
```

**Что произошло:**
```
drizzle/
├── 0000_initial_schema.sql          # Предыдущие миграции
├── 0001_add_sponsor_name.sql        # ✅ НОВАЯ миграция!
└── meta/
    └── _journal.json                # История миграций
```

**Содержимое миграции:**
```sql
-- drizzle/0001_add_sponsor_name.sql
ALTER TABLE "races" ADD COLUMN "sponsor_name" varchar(255);
```

#### 4. Проверяем и применяем

```bash
# Проверяем что SQL правильный
cat drizzle/0001_add_sponsor_name.sql

# Применяем миграцию к БД
npm run db:migrate
```

**Что произошло:**
- Drizzle выполнил SQL из миграции
- Запомнил что миграция `0001` применена
- При следующем `db:migrate` эта миграция пропустится

#### 5. Коммитим в git

```bash
git add shared/schema.ts
git add drizzle/0001_add_sponsor_name.sql
git commit -m "feat: add sponsor name to races"
```

**Теперь:**
- ✅ История изменений в git
- ✅ Команда видит что изменилось
- ✅ CI/CD может применить автоматически

---

### Откат миграции (Rollback)

**Если что-то пошло не так:**

```bash
# Создаём миграцию для отката
# (Drizzle не имеет автоматического rollback, но можно вручную)
```

```sql
-- drizzle/0002_rollback_sponsor_name.sql
ALTER TABLE "races" DROP COLUMN "sponsor_name";
```

```bash
npm run db:migrate  # Применяем откат
```

**Преимущества:**
- ✅ Можно откатить изменения
- ✅ История сохранена (видно что было откачено)
- ✅ Безопасно для production

---

## 🛠️ Правильный workflow для 527 ShortCut

### Текущий (неправильный):

```bash
# ❌ Разработчик меняет schema.ts
npm run db:push  # Прямо в БД, без истории
```

### Правильный:

```bash
# 1. Меняешь schema.ts
vim shared/schema.ts

# 2. Генерируешь миграцию
npm run db:generate

# 3. Проверяешь SQL
cat drizzle/XXXX_migration_name.sql

# 4. Применяешь локально
npm run db:migrate

# 5. Тестируешь что всё работает
npm run dev

# 6. Коммитишь в git
git add shared/schema.ts drizzle/
git commit -m "migration: add new field"

# 7. Push в GitHub
git push

# 8. Railway auto-deploy применит миграцию
# (в build command добавить: npm run db:migrate)
```

---

## 🔄 Migration в CI/CD (Railway)

### Настройка автоматического применения миграций

**Railway Build Settings:**
```json
{
  "buildCommand": "npm run build && npm run db:migrate",
  "startCommand": "npm start"
}
```

**Что происходит:**
1. Railway получает новый commit
2. Запускает build (компилирует код)
3. **Запускает миграции** (`npm run db:migrate`)
4. Запускает приложение

**Безопасность:**
- ✅ Миграции применяются автоматически
- ✅ В правильном порядке (по timestamp)
- ✅ Если миграция провалилась → deploy останавливается
- ✅ Production защищён от ошибок

---

## 📋 Чек-лист Database setup

### Schema организация ✅
- [ ] Schema в `shared/schema.ts` (SSOT!)
- [ ] TypeScript типы экспортируются
- [ ] Relations между таблицами описаны
- [ ] Backend и Frontend используют одинаковые типы

### Drizzle ORM setup ✅
- [ ] `drizzle-orm` установлен
- [ ] `drizzle-kit` установлен (dev dependency)
- [ ] `drizzle.config.ts` настроен
- [ ] Connection к БД работает

### Миграции (КРИТИЧНО!) ✅
- [ ] НЕ используешь `db:push` в production
- [ ] `npm run db:generate` создаёт миграции
- [ ] Миграции в `drizzle/` папке
- [ ] Миграции в git (история изменений)
- [ ] CI/CD применяет миграции автоматически

### Production safety ✅
- [ ] Local и Production БД разделены
- [ ] Environment variables для DATABASE_URL
- [ ] Backups настроены (Railway делает автоматически)
- [ ] Rollback план есть

---

## 🎓 Итоги урока

### Главные выводы

1. **Drizzle ORM** - отличный выбор для TypeScript проектов

2. **shared/schema.ts в 527 ShortCut - ГЕНИАЛЬНО!** ✅
   - SSOT принцип соблюдён
   - Типы автоматически везде
   - Refactoring безопасный

3. **db:push - ОПАСНО для production!** ❌
   - Может удалить данные
   - Нет истории изменений
   - Невозможно откатить

4. **Миграции - единственный правильный способ:**
   - ✅ История изменений в git
   - ✅ Можно откатить
   - ✅ CI/CD friendly
   - ✅ Team friendly

5. **Цена ошибки:**
   - Внедрить миграции СЕЙЧАС: 1 день
   - Ликвидировать инцидент с данными: недели + репутация

### Что дальше?

В следующем уроке:
- Frontend setup (React + Vite)
- Связка с backend через API
- TypeScript типы из shared/

---

## 🔗 Ссылки на другие уроки

### Project Setup Guide
- → **Урок 1.7** (SSOT принцип) - основа shared/schema.ts
- → **Урок 4.3** (Структура папок) - предыдущий урок
- → **Урок 4.5** (Frontend React) - следующий урок

### AI Web Learning
- → **Module 3** (Database basics) - SQL vs NoSQL, основы БД
- → **Module 3.3** (Migrations) - детали миграций

---

## 💡 Задание для практики

**Задача:** Настрой миграции в своём Express проекте.

**Шаги:**
1. Создай `drizzle.config.ts`
2. Добавь scripts в `package.json`:
   - `"db:generate": "drizzle-kit generate"`
   - `"db:migrate": "drizzle-kit migrate"`
3. Измени schema.ts (добавь поле)
4. Сгенерируй миграцию: `npm run db:generate`
5. Проверь SQL файл
6. Примени: `npm run db:migrate`
7. Закоммить schema + миграцию в git

**Проверка:**  
В `drizzle/` должны появиться SQL файлы миграций.

---

## ⚠️ Важное напоминание

**Для 527 ShortCut разработчика:**

```
СЕЙЧАС используется: npm run db:push

ПРОБЛЕМА:
├── ❌ Production данные под риском
├── ❌ Нет истории изменений
└── ❌ Невозможно откатить

РЕШЕНИЕ:
├── ✅ Внедрить миграции (1 день работы)
├── ✅ Обновить Railway build command
└── ✅ Спать спокойно (данные в безопасности)

ЦЕНА ОШИБКИ:
├── Не внедрить: потенциальная потеря данных
├── Внедрить: 1 день работы + защита
└── Выбор очевиден
```

---

**Последнее обновление:** 2025-10-29  
**Автор:** AI Web Learning Course
