# 4.5 Инициализация Frontend (React + Vite)

> **Время изучения:** 35-45 минут  
> **Сложность:** ⭐ Практический урок  
> **Prerequisite:** Урок 4.2 (Инициализация Backend), Урок 4.4 (Database)

---

## 🎯 Цель урока

Научиться **правильно создавать** React + Vite frontend для Express backend. Мы настроим TypeScript, используем типы из shared/schema.ts, и создадим API клиент для запросов к backend.

**Почему это важно:**  
Правильная структура frontend = переиспользуемые компоненты, type safety, легко масштабировать.

---

## 🏗️ Архитектура Frontend + Backend

```
project/
│
├── server/               # Backend (Express)
│   ├── index.ts
│   └── routes/
│
├── shared/              # ✅ SSOT для типов!
│   └── schema.ts
│
└── client/              # Frontend (React)
    ├── src/
    │   ├── components/  # Переиспользуемые компоненты
    │   ├── pages/       # Страницы
    │   ├── services/    # API клиент
    │   └── App.tsx      # Main app
    └── index.html
```

**Главная идея:**  
Frontend использует типы из `shared/schema.ts` - нет расхождений между API и UI!

---

## 📦 Шаг 1: Создание React + Vite проекта

### 1.1 Создаём проект

```bash
# Из корня проекта создаём client/ папку
npm create vite@latest client -- --template react-ts

# Переходим в client/
cd client

# Устанавливаем зависимости
npm install
```

**Что произошло:**
- Создалась папка `client/` с React + TypeScript проектом
- Vite настроен как build tool
- TypeScript конфигурация готова

### 1.2 Первый запуск

```bash
npm run dev
```

Vite запустится на `http://localhost:5173`

**Видишь:**
```
VITE v5.0.0  ready in 500 ms

➜  Local:   http://localhost:5173/
➜  Network: use --host to expose
```

🎉 **React работает!**

---

## ⚙️ Шаг 2: Настройка TypeScript

### 2.1 Обновляем tsconfig.json

```json
// client/tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

    /* Paths для shared типов */
    "baseUrl": ".",
    "paths": {
      "@/*": ["../src/*"],
      "@shared/*": ["../shared/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

**Ключевые настройки:**
- `"strict": true"` - строгая проверка типов
- `"paths"` - можем писать `import { Race } from '@shared/schema'`
- `"jsx": "react-jsx"` - поддержка React

---

## 📁 Шаг 3: Структура папок Frontend

### Правильная организация

```
client/
├── src/
│   ├── components/        # Переиспользуемые компоненты
│   │   ├── Navigation.tsx
│   │   ├── RaceCard.tsx
│   │   └── ResultsTable.tsx
│   │
│   ├── pages/            # Страницы (routes)
│   │   ├── Home.tsx
│   │   ├── Results.tsx
│   │   ├── News.tsx
│   │   └── Teams.tsx
│   │
│   ├── services/         # API клиент
│   │   └── api.ts
│   │
│   ├── types/            # Frontend-specific типы (если нужны)
│   │   └── index.ts
│   │
│   ├── utils/            # Вспомогательные функции
│   │   └── formatters.ts
│   │
│   ├── App.tsx           # Main app component + routing
│   ├── main.tsx          # Entry point
│   └── index.css         # Global styles
│
├── public/               # Статические файлы
│   ├── images/
│   └── favicon.ico
│
└── index.html            # HTML entry point
```

**Принципы:**
- `components/` - переиспользуемые UI элементы
- `pages/` - полные страницы (по одной на route)
- `services/` - вся логика запросов к API в одном месте
- `types/` - только frontend-специфичные типы (большинство из shared/)

---

## 🔗 Шаг 4: Использование типов из shared/

### 4.1 Импорт типов в компоненты

```typescript
// client/src/pages/Results.tsx
import { useState, useEffect } from 'react';
import { Race, Result } from '@shared/schema';  // ✅ Типы из backend!

function ResultsPage() {
  const [races, setRaces] = useState<Race[]>([]);
  const [results, setResults] = useState<Result[]>([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Fetch races from API
    fetch('/api/races')
      .then(res => res.json())
      .then((data: Race[]) => {
        setRaces(data);
        setLoading(false);
      });
  }, []);
  
  if (loading) return <div>Loading...</div>;
  
  return (
    <div>
      <h1>Race Results</h1>
      {races.map(race => (
        <div key={race.id}>
          <h2>{race.name}</h2>
          {/* TypeScript знает все поля Race! */}
          <p>Stage: {race.stageNumber} / {race.totalStages}</p>
          <p>Status: {race.status}</p>
          <p>Date: {race.startDate} - {race.endDate}</p>
        </div>
      ))}
    </div>
  );
}

export default ResultsPage;
```

**Магия TypeScript:**
```typescript
const race = races[0];

race.name          // ✅ string (TypeScript знает!)
race.stageNumber   // ✅ number
race.wrongField    // ❌ TypeScript ошибка: нет такого поля
```

### 4.2 Преимущества shared типов

```
┌─────────────────────────────────────────────────────────────┐
│        ✅ ПРЕИМУЩЕСТВА shared типов в Frontend              │
└─────────────────────────────────────────────────────────────┘

1. Type Safety от API до UI
   ├── Backend отдаёт Race[]
   ├── Frontend ожидает Race[]
   └── TypeScript проверяет соответствие

2. Refactoring безопасный
   ├── Изменил поле в schema.ts
   ├── TypeScript покажет ВСЕ места в UI где используется
   └── Невозможно забыть обновить

3. Autocomplete в IDE
   ├── Пишешь race.
   ├── IDE показывает все доступные поля
   └── Быстрая разработка

4. Нет расхождений API ↔ UI
   ├── Backend и Frontend видят одинаковую структуру
   ├── Нет ситуации "API изменился, а UI старый"
   └── Меньше багов в production
```

---

## 🌐 Шаг 5: API клиент

### 5.1 Создаём централизованный API клиент

```typescript
// client/src/services/api.ts
import { Race, Result, ChampionshipStanding } from '@shared/schema';

const API_BASE = '/api';

export const api = {
  // Races
  async getRaces(): Promise<Race[]> {
    const res = await fetch(`${API_BASE}/races`);
    if (!res.ok) throw new Error('Failed to fetch races');
    return res.json();
  },
  
  async getRaceById(id: number): Promise<Race> {
    const res = await fetch(`${API_BASE}/races/${id}`);
    if (!res.ok) throw new Error('Failed to fetch race');
    return res.json();
  },
  
  async getRaceResults(raceId: number, sessionType: string): Promise<Result[]> {
    const res = await fetch(`${API_BASE}/races/${raceId}/results/${sessionType}`);
    if (!res.ok) throw new Error('Failed to fetch results');
    return res.json();
  },
  
  // Standings
  async getOverallStandings(): Promise<ChampionshipStanding[]> {
    const res = await fetch(`${API_BASE}/standings/overall`);
    if (!res.ok) throw new Error('Failed to fetch standings');
    return res.json();
  },
  
  async getStageStandings(stageNumber: number): Promise<ChampionshipStanding[]> {
    const res = await fetch(`${API_BASE}/standings/stage/${stageNumber}`);
    if (!res.ok) throw new Error('Failed to fetch stage standings');
    return res.json();
  },
};
```

**Преимущества:**
- ✅ Все API запросы в одном месте
- ✅ TypeScript типы для всех методов
- ✅ Легко изменить API_BASE (dev vs production)
- ✅ Централизованная обработка ошибок

### 5.2 Использование API клиента в компонентах

```typescript
// client/src/pages/Results.tsx
import { useState, useEffect } from 'react';
import { api } from '../services/api';
import { Race } from '@shared/schema';

function ResultsPage() {
  const [races, setRaces] = useState<Race[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    api.getRaces()
      .then(setRaces)
      .catch(err => setError(err.message))
      .finally(() => setLoading(false));
  }, []);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return (
    <div>
      <h1>Races</h1>
      {races.map(race => (
        <div key={race.id}>{race.name}</div>
      ))}
    </div>
  );
}
```

**Чище и понятнее!**

---

## 🔧 Шаг 6: Vite Proxy для Development

### 6.1 Проблема: CORS в development

```
Frontend:  http://localhost:5173  (Vite)
Backend:   http://localhost:3000  (Express)

Проблема: Разные порты = CORS ошибка!
```

### 6.2 Решение: Vite Proxy

```typescript
// client/vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  
  // Proxy для API запросов
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true,
      }
    }
  },
  
  // Resolve для @shared imports
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@shared': path.resolve(__dirname, '../shared'),
    }
  }
});
```

**Как работает:**
```
Frontend делает запрос:  fetch('/api/races')
                         ↓
Vite Proxy перенаправляет: http://localhost:3000/api/races
                         ↓
Express Backend отвечает: Race[]
                         ↓
Frontend получает:      Race[] (без CORS проблем!)
```

**Преимущества:**
- ✅ Нет CORS ошибок в development
- ✅ Frontend думает что API на том же домене
- ✅ В production не нужен (всё на одном домене)

---

## 🎨 Шаг 7: Routing с React Router

### 7.1 Установка React Router

```bash
npm install react-router-dom
```

### 7.2 Настройка роутинга

```typescript
// client/src/App.tsx
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import Navigation from './components/Navigation';
import Home from './pages/Home';
import Results from './pages/Results';
import News from './pages/News';
import Teams from './pages/Teams';

function App() {
  return (
    <BrowserRouter>
      <Navigation />
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/results" element={<Results />} />
        <Route path="/news" element={<News />} />
        <Route path="/teams" element={<Teams />} />
      </Routes>
    </BrowserRouter>
  );
}

export default App;
```

```typescript
// client/src/components/Navigation.tsx
import { Link } from 'react-router-dom';

function Navigation() {
  return (
    <nav>
      <Link to="/">Home</Link>
      <Link to="/results">Results</Link>
      <Link to="/news">News</Link>
      <Link to="/teams">Teams</Link>
    </nav>
  );
}

export default Navigation;
```

**Готово!** Client-side routing работает.

---

## ✅ Что сделано ХОРОШО в 527 ShortCut Frontend

### 1. Структура папок ✅

```
client/src/
├── components/    # Переиспользуемые компоненты
├── pages/         # Страницы
├── data/          # Статические данные
└── App.tsx        # Main app + routing
```

**Всё правильно организовано!**

### 2. TypeScript везде ✅

Весь frontend на TypeScript - type safety от API до UI.

### 3. Vite как build tool ✅

Vite - современный, быстрый bundler. Правильный выбор!

### 4. React Router для навигации ✅

Client-side routing настроен правильно.

---

## 📦 Шаг 8: Production Build

### 8.1 Build frontend

```bash
cd client
npm run build
```

**Что происходит:**
- Vite компилирует TypeScript → JavaScript
- Минифицирует код
- Оптимизирует assets (images, CSS)
- Создаёт `client/dist/` папку

**Результат:**
```
client/dist/
├── index.html         # Entry HTML
└── assets/
    ├── index-abc123.js    # JS bundle (минифицированный)
    └── index-xyz789.css   # CSS bundle
```

### 8.2 Serving frontend через Express

```typescript
// server/index.ts
import express from 'express';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();

// API routes
app.use('/api', routes);

// Serve static frontend (production)
if (process.env.NODE_ENV === 'production') {
  app.use(express.static(path.join(__dirname, '../client/dist')));
  
  // SPA fallback (все routes отдают index.html)
  app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, '../client/dist/index.html'));
  });
}

app.listen(3000);
```

**Как работает:**
```
Production:
├── Express отдаёт /api/* → API responses
└── Express отдаёт /* → index.html (React SPA)

Development:
├── Express на :3000 → API
└── Vite на :5173 → Frontend (hot reload)
```

---

## 🛠️ package.json Scripts

### Корневой package.json

```json
{
  "name": "express-react-app",
  "scripts": {
    "dev": "concurrently \"npm run dev:server\" \"npm run dev:client\"",
    "dev:server": "tsx watch server/index.ts",
    "dev:client": "cd client && npm run dev",
    
    "build": "npm run build:server && npm run build:client",
    "build:server": "node build-server.js",
    "build:client": "cd client && npm run build",
    
    "start": "node dist/index.js"
  },
  "devDependencies": {
    "concurrently": "^8.2.2"
  }
}
```

**Команды:**
- `npm run dev` - запускает backend + frontend одновременно
- `npm run build` - собирает production версию
- `npm start` - запускает production

---

## 📋 Чек-лист Frontend setup

### React + Vite инициализация ✅
- [ ] `npm create vite@latest client` выполнен
- [ ] TypeScript шаблон выбран
- [ ] Зависимости установлены
- [ ] `npm run dev` запускается без ошибок

### TypeScript конфигурация ✅
- [ ] `tsconfig.json` настроен
- [ ] `"strict": true"` включён
- [ ] Paths для `@shared` настроены
- [ ] Импорты из shared/ работают

### Структура папок ✅
- [ ] `components/` для переиспользуемых UI
- [ ] `pages/` для страниц (routes)
- [ ] `services/` для API клиента
- [ ] Каждый файл < 300 строк

### API клиент ✅
- [ ] Создан `services/api.ts`
- [ ] Все API методы централизованы
- [ ] TypeScript типы из shared/ используются
- [ ] Error handling добавлен

### Vite конфигурация ✅
- [ ] Proxy для `/api` настроен
- [ ] Alias для `@shared` работает
- [ ] Development server на :5173
- [ ] Production build работает

### Routing ✅
- [ ] React Router установлен
- [ ] Routes настроены
- [ ] Navigation компонент создан
- [ ] SPA fallback в Express (production)

---

## 🎓 Итоги урока

### Главные выводы

1. **React + Vite** - современный и быстрый стек для frontend

2. **Типы из shared/** - type safety от backend до UI

3. **API клиент централизован** - все запросы в services/api.ts

4. **Vite Proxy** - решает CORS проблемы в development

5. **527 ShortCut frontend** - всё сделано правильно! ✅

### Что дальше?

В следующем уроке:
- Связка ВСЕХ частей проекта
- **ПОЛНЫЙ анализ 527 ShortCut** с жёсткой критикой
- Итоговая оценка архитектуры
- План рефакторинга

---

## 🔗 Ссылки на другие уроки

### Project Setup Guide
- → **Урок 2.3** (React + Vite для FastAPI) - похожий setup
- → **Урок 4.4** (Database Drizzle) - предыдущий урок
- → **Урок 4.6** (Связка + Анализ) - следующий урок ⭐⭐

### AI Web Learning
- → **Module 4** (Frontend basics) - React, components, state
- → **Module 8.5** (Vite build tool) - детали Vite

---

## 💡 Задание для практики

**Задача:** Создай страницу Results в своём проекте.

**Требования:**
- Используй типы из shared/schema.ts
- API клиент для fetch запросов
- Обработка loading и error состояний
- TypeScript strict mode

**Проверка:**  
TypeScript должен показывать автокомплит для полей из Race и Result типов.

---

**Последнее обновление:** 2025-10-29  
**Автор:** AI Web Learning Course
