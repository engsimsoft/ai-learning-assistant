# 1.1 Философия правильной организации проекта

#### 🎯 Почему структура проекта критична

**Проблема хаотичной структуры:**
- Через 3 месяца не найдёшь нужный файл
- ИИ путается в твоём коде
- Новый функционал добавляется в случайные места
- Рефакторинг становится невозможным
- Документация дублируется и устаревает

**Хорошая структура даёт:**
- ✅ Быстро найти любой файл (интуитивно понятно где что лежит)
- ✅ ИИ лучше понимает контекст и предлагает правильные решения
- ✅ Легко масштабировать (добавлять новые фичи)
- ✅ Просто онбордить новых разработчиков
- ✅ Код остаётся чистым и поддерживаемым

---

#### 🏗️ Слоистая архитектура (Layered Architecture)

**Концепция:**
Код разделён на слои по функциональности. Каждый слой общается только с соседними слоями.

**Визуализация слоистой архитектуры:**

> **Что такое ASCII схема?** Это рисунок из текстовых символов - стрелок, линий, рамок. Мы используем их чтобы показать процессы и связи наглядно, прямо в тексте. Это как блок-схема, но нарисованная символами ┌─┐│└┘↓.

```
┌─────────────────────────────────────────────────────────┐
│                    🌐 PRESENTATION LAYER                 │
│                  (Routes / API Endpoints)                │
│                                                          │
│  • Получает HTTP запросы                                │
│  • Валидирует входные данные (Pydantic)                 │
│  • Вызывает Business Logic                              │
│  • Возвращает HTTP ответы                               │
│                                                          │
├─────────────────────────────────────────────────────────┤
│                   🧠 BUSINESS LOGIC LAYER                │
│                    (Services / Core)                     │
│                                                          │
│  • Вся бизнес-логика приложения                         │
│  • Расчёты, обработка данных                            │
│  • Валидация бизнес-правил                              │
│  • НЕ знает про HTTP/JSON                               │
│                                                          │
├─────────────────────────────────────────────────────────┤
│                    💾 DATA ACCESS LAYER                  │
│                   (Models / Repositories)                │
│                                                          │
│  • Работа с базой данных                                │
│  • CRUD операции                                        │
│  • Схемы данных (SQLAlchemy, Pydantic)                  │
│  • НЕ знает про бизнес-логику                           │
│                                                          │
├─────────────────────────────────────────────────────────┤
│                    🗄️ DATABASE                           │
│                (PostgreSQL / SQLite)                     │
│                                                          │
│  • Хранение данных                                      │
│  • Транзакции, индексы                                  │
│                                                          │
└─────────────────────────────────────────────────────────┘

                    ПОТОК ДАННЫХ:
                    
    HTTP Request → Routes → Services → Models → Database
                     ↓         ↓          ↓         ↓
    HTTP Response ← Routes ← Services ← Models ← Database
```

**Почему это правильно:**

- **Routes** (endpoints) - только маршрутизация, никакой логики
- **Services** - вся бизнес-логика изолирована, можно тестировать отдельно
- **Models** - работа с БД, не знают про HTTP
- **Separation of Concerns** - каждый слой делает одно дело

---

#### ✅ Признаки хорошей структуры

**Логическое разделение:**
```
✅ app/routers/cams.py       # Endpoint /api/cams
✅ app/services/cam_service.py  # Расчёты кулачков
✅ app/models/cam.py         # Модель Cam для БД
✅ app/schemas/cam.py        # Pydantic схема для API
```

**Повторяющиеся паттерны:**
- Файлы названы по функциональности (`cam_service.py`, `user_service.py`)
- Одинаковая структура в каждом модуле
- Понятно где искать код для фичи X

**Конфиги отдельно:**
```
✅ app/core/config.py        # Настройки приложения
✅ app/core/database.py      # Подключение к БД
✅ .env                      # Секреты (не в коде!)
```

**Тесты организованы:**
```
✅ tests/test_routes/        # Тесты endpoints
✅ tests/test_services/      # Тесты бизнес-логики
✅ tests/test_models/        # Тесты моделей
```

---

#### ❌ Признаки плохой структуры

**Все файлы в корне:**
```
❌ main.py
❌ utils.py
❌ helpers.py
❌ stuff.py
❌ temp.py
❌ new_feature.py
```

**Бизнес-логика в routes:**
```python
❌ # app/routes/cams.py
@router.post("/calculate")
async def calculate(data: dict):
    # 200 строк расчётов прямо в endpoint
    result = complex_calculation_here()
    return result
```

**Смешанные ответственности:**
```python
❌ # app/models/cam.py
class Cam(Base):
    # Модель БД + бизнес-логика + API логика
    def calculate_profile(self):  # Бизнес-логика в модели БД
        ...
    def to_json(self):  # API логика в модели БД
        ...
```

**Дублирование кода:**
```
❌ app/utils/validators.py
❌ app/helpers/validation.py
❌ app/common/validate.py
# Одна и та же валидация в 3 местах
```

---

#### 📐 Принципы правильной организации

**1. Single Responsibility Principle (SRP)**
- Каждый файл/класс/функция делает одно дело
- `cam_service.py` - только бизнес-логика кулачков
- `cam_routes.py` - только API endpoints для кулачков

**2. Don't Repeat Yourself (DRY)**
- Код живёт в одном месте
- Дублирование = источник багов
- Shared код → `app/utils/` или `app/common/`

**3. Separation of Concerns**
- Routes не знают про БД
- Services не знают про HTTP
- Models не знают про бизнес-логику

**4. Понятное именование**
```
✅ user_service.py         (понятно что внутри)
✅ authentication.py       (понятно что внутри)
❌ utils.py                (всё что угодно)
❌ helpers.py              (всё что угодно)
```

---

#### 🎯 Best Practices

**Для FastAPI проекта:**
```
app/
├── routers/          # API endpoints (Presentation)
├── services/         # Бизнес-логика (Business Logic)
├── models/           # SQLAlchemy модели (Data Access)
├── schemas/          # Pydantic схемы (Validation)
├── core/             # Конфиги, database connection
├── utils/            # Общие утилиты
└── main.py           # Точка входа
```

**Для Next.js проекта:**
```
app/
├── (routes)/         # Страницы и layouts
├── api/              # API routes
components/           # React компоненты
├── ui/               # Переиспользуемые UI
├── features/         # Компоненты бизнес-логики
lib/                  # Утилиты, helpers
```

---

#### 🤖 Диалог с Claude Code

**❌ Плохой диалог:**
```
Ты: Создай FastAPI проект

Claude Code: [создаёт всё в app/main.py]
```

**Почему плохо:**
- Нет деталей о структуре
- ИИ не понимает контекст
- Получаешь монолит в одном файле

**✅ Хороший диалог:**
```
Ты: Создай FastAPI проект со следующей структурой:

app/
├── routers/       # API endpoints
│   ЗАЧЕМ: Отделить HTTP логику от бизнес-логики
├── services/      # Бизнес-логика
│   ЗАЧЕМ: Изолировать расчёты, легко тестировать
├── models/        # SQLAlchemy модели БД
│   ЗАЧЕМ: Работа с БД отдельно
├── schemas/       # Pydantic схемы для API
│   ЗАЧЕМ: Валидация входных/выходных данных
├── core/          # Config, database connection
│   ├── config.py
│   │   ЗАЧЕМ: Централизованные настройки
│   └── database.py
│       ЗАЧЕМ: Подключение к БД в одном месте
└── main.py        # Entry point
    ЗАЧЕМ: Точка входа приложения

Следуй Layered Architecture:
- Routes только маршрутизация (HTTP)
  ЗАЧЕМ: Чистое разделение, легко менять API
- Services вся бизнес-логика
  ЗАЧЕМ: Можно тестировать без HTTP
- Models только работа с БД
  ЗАЧЕМ: Изоляция данных

ТРЕБОВАНИЯ:
- Pydantic валидация
  ЗАЧЕМ: Проверять данные до расчётов
- CORS middleware
  ЗАЧЕМ: Frontend сможет обращаться
- Swagger docs (/docs)
  ЗАЧЕМ: Увидеть все endpoints

Claude Code: [создаёт правильную структуру]
```

**Почему хорошо:**
- ✅ Детальная структура с объяснением ЗАЧЕМ каждая папка
- ✅ Объяснение ЗАЧЕМ каждое требование
- ✅ ИИ понимает контекст и архитектурные принципы
- ✅ Получаешь production-ready структуру

---

#### ✅ Чек-лист хорошей структуры

**Проверь свой проект:**

- [ ] Код разделён на логические слои (routes, services, models)
- [ ] Нет бизнес-логики в routes
- [ ] Нет HTTP логики в services
- [ ] Конфиги вынесены в отдельные файлы
- [ ] Секреты в .env, не в коде
- [ ] Тесты отражают структуру кода
- [ ] Понятно где искать код для фичи X
- [ ] Нет файлов utils.py, helpers.py, stuff.py
- [ ] Файлы названы по функциональности
- [ ] Дублирование кода минимально

**Если хотя бы 3 пункта не выполнены → нужен рефакторинг!**

---

**Следующий раздел:** 1.2 Инициализация проекта